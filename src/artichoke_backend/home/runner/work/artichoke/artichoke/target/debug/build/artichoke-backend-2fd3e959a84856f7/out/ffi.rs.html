<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Source of the Rust file `/home/runner/work/artichoke/artichoke/target/debug/build/artichoke-backend-2fd3e959a84856f7/out/ffi.rs`."><title>ffi.rs - source</title><script> if (window.location.protocol !== "file:") document.write(`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../../../../../../../../../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../../../../../../../../../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../../../../../../../../../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../../../../../../../../../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../../../../../../../../../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2">`)</script><link rel="stylesheet" href="../../../../../../../../../../../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../../../../../../../../../../../static.files/rustdoc-e935ef01ae1c1829.css"><meta name="rustdoc-vars" data-root-path="../../../../../../../../../../../../" data-static-root-path="../../../../../../../../../../../../static.files/" data-current-crate="artichoke_backend" data-themes="" data-resource-suffix="" data-rustdoc-version="1.79.0-nightly (0824b300e 2024-03-24)" data-channel="nightly" data-search-js="search-42d8da7a6b9792c2.js" data-settings-js="settings-4313503d2e1961c2.js" ><script src="../../../../../../../../../../../../static.files/storage-4c98445ec4002617.js"></script><script defer src="../../../../../../../../../../../../static.files/src-script-e66d777a5a92e9b2.js"></script><script defer src="../../../../../../../../../../../../src-files.js"></script><script defer src="../../../../../../../../../../../../static.files/main-12cf3b4f4f9dc36d.js"></script><noscript><link rel="stylesheet" href="../../../../../../../../../../../../static.files/noscript-04d5337699b92874.css"></noscript><link rel="icon" href="https://www.artichokeruby.org/favicon-32x32.png"></head><body class="rustdoc src"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="src-sidebar-title">
            <h2>Files</h2></div></nav><div class="sidebar-resizer"></div>
    <main><nav class="sub"><form class="search-form"><span></span><div id="sidebar-button" tabindex="-1"><a href="../../../../../../../../../../../../artichoke_backend/all.html" title="show sidebar"></a></div><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" tabindex="-1"><a href="../../../../../../../../../../../../help.html" title="help">?</a></div><div id="settings-menu" tabindex="-1"><a href="../../../../../../../../../../../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../../../../../../../../../../../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="example-wrap"><div data-nosnippet><pre class="src-line-numbers"><a href="#1" id="1">1</a>
<a href="#2" id="2">2</a>
<a href="#3" id="3">3</a>
</pre></div><pre class="rust"><code><span class="comment">/* automatically generated by rust-bindgen 0.69.4 */

</span># [repr (C)] # [derive (Copy , Clone , Debug , Default , Eq , Hash , Ord , PartialEq , PartialOrd)] <span class="kw">pub struct </span>__BindgenBitfieldUnit &lt; Storage &gt; { storage : Storage , } <span class="kw">impl </span>&lt; Storage &gt; __BindgenBitfieldUnit &lt; Storage &gt; { # [inline] <span class="kw">pub const fn </span>new (storage : Storage) -&gt; <span class="self">Self </span>{ <span class="self">Self </span>{ storage } } } <span class="kw">impl </span>&lt; Storage &gt; __BindgenBitfieldUnit &lt; Storage &gt; <span class="kw">where </span>Storage : AsRef &lt; [u8] &gt; + AsMut &lt; [u8] &gt;, { # [inline] <span class="kw">pub fn </span>get_bit (&amp; <span class="self">self </span>, index : usize) -&gt; bool { debug_assert ! (index / <span class="number">8 </span>&lt; <span class="self">self </span>. storage . as_ref () . len ()) ; <span class="kw">let </span>byte_index = index / <span class="number">8 </span>; <span class="kw">let </span>byte = <span class="self">self </span>. storage . as_ref () [byte_index] ; <span class="kw">let </span>bit_index = <span class="kw">if </span>cfg ! (target_endian = <span class="string">"big"</span>) { <span class="number">7 </span>- (index % <span class="number">8</span>) } <span class="kw">else </span>{ index % <span class="number">8 </span>} ; <span class="kw">let </span>mask = <span class="number">1 </span>&lt;&lt; bit_index ; byte &amp; mask == mask } # [inline] <span class="kw">pub fn </span>set_bit (&amp; <span class="kw-2">mut </span><span class="self">self </span>, index : usize , val : bool) { debug_assert ! (index / <span class="number">8 </span>&lt; <span class="self">self </span>. storage . as_ref () . len ()) ; <span class="kw">let </span>byte_index = index / <span class="number">8 </span>; <span class="kw">let </span>byte = &amp; <span class="kw-2">mut </span><span class="self">self </span>. storage . as_mut () [byte_index] ; <span class="kw">let </span>bit_index = <span class="kw">if </span>cfg ! (target_endian = <span class="string">"big"</span>) { <span class="number">7 </span>- (index % <span class="number">8</span>) } <span class="kw">else </span>{ index % <span class="number">8 </span>} ; <span class="kw">let </span>mask = <span class="number">1 </span>&lt;&lt; bit_index ; <span class="kw">if </span>val { * byte |= mask ; } <span class="kw">else </span>{ * byte &amp;= ! mask ; } } # [inline] <span class="kw">pub fn </span>get (&amp; <span class="self">self </span>, bit_offset : usize , bit_width : u8) -&gt; u64 { debug_assert ! (bit_width &lt;= <span class="number">64</span>) ; debug_assert ! (bit_offset / <span class="number">8 </span>&lt; <span class="self">self </span>. storage . as_ref () . len ()) ; debug_assert ! ((bit_offset + (bit_width <span class="kw">as </span>usize)) / <span class="number">8 </span>&lt;= <span class="self">self </span>. storage . as_ref () . len ()) ; <span class="kw">let </span><span class="kw-2">mut </span>val = <span class="number">0 </span>; <span class="kw">for </span>i <span class="kw">in </span><span class="number">0 </span>.. (bit_width <span class="kw">as </span>usize) { <span class="kw">if </span><span class="self">self </span>. get_bit (i + bit_offset) { <span class="kw">let </span>index = <span class="kw">if </span>cfg ! (target_endian = <span class="string">"big"</span>) { bit_width <span class="kw">as </span>usize - <span class="number">1 </span>- i } <span class="kw">else </span>{ i } ; val |= <span class="number">1 </span>&lt;&lt; index ; } } val } # [inline] <span class="kw">pub fn </span>set (&amp; <span class="kw-2">mut </span><span class="self">self </span>, bit_offset : usize , bit_width : u8 , val : u64) { debug_assert ! (bit_width &lt;= <span class="number">64</span>) ; debug_assert ! (bit_offset / <span class="number">8 </span>&lt; <span class="self">self </span>. storage . as_ref () . len ()) ; debug_assert ! ((bit_offset + (bit_width <span class="kw">as </span>usize)) / <span class="number">8 </span>&lt;= <span class="self">self </span>. storage . as_ref () . len ()) ; <span class="kw">for </span>i <span class="kw">in </span><span class="number">0 </span>.. (bit_width <span class="kw">as </span>usize) { <span class="kw">let </span>mask = <span class="number">1 </span>&lt;&lt; i ; <span class="kw">let </span>val_bit_is_set = val &amp; mask == mask ; <span class="kw">let </span>index = <span class="kw">if </span>cfg ! (target_endian = <span class="string">"big"</span>) { bit_width <span class="kw">as </span>usize - <span class="number">1 </span>- i } <span class="kw">else </span>{ i } ; <span class="self">self </span>. set_bit (index + bit_offset , val_bit_is_set) ; } } } <span class="kw">pub const </span>MRB_INT_BIT : u32 = <span class="number">64 </span>; <span class="kw">pub const </span>MRB_PRIo : &amp; [u8 ; <span class="number">3</span>] = <span class="string">b"lo\0" </span>; <span class="kw">pub const </span>MRB_PRId : &amp; [u8 ; <span class="number">3</span>] = <span class="string">b"ld\0" </span>; <span class="kw">pub const </span>MRB_PRIx : &amp; [u8 ; <span class="number">3</span>] = <span class="string">b"lx\0" </span>; <span class="kw">pub const </span>MRB_FL_OBJ_IS_FROZEN : u32 = <span class="number">1048576 </span>; <span class="kw">pub const </span>MRB_FIXNUM_SHIFT : u32 = <span class="number">0 </span>; <span class="kw">pub const </span>MRB_SYMBOL_SHIFT : u32 = <span class="number">0 </span>; <span class="kw">pub const </span>MRB_EACH_OBJ_OK : u32 = <span class="number">0 </span>; <span class="kw">pub const </span>MRB_EACH_OBJ_BREAK : u32 = <span class="number">1 </span>; <span class="kw">pub const </span>MRB_GC_ARENA_SIZE : u32 = <span class="number">100 </span>; <span class="kw">pub const </span>MRB_GC_RED : u32 = <span class="number">7 </span>; <span class="kw">pub const </span>MRUBY_RUBY_VERSION : &amp; [u8 ; <span class="number">4</span>] = <span class="string">b"3.2\0" </span>; <span class="kw">pub const </span>MRUBY_RUBY_ENGINE : &amp; [u8 ; <span class="number">6</span>] = <span class="string">b"mruby\0" </span>; <span class="kw">pub const </span>MRUBY_RELEASE_MAJOR : u32 = <span class="number">3 </span>; <span class="kw">pub const </span>MRUBY_RELEASE_MINOR : u32 = <span class="number">2 </span>; <span class="kw">pub const </span>MRUBY_RELEASE_TEENY : u32 = <span class="number">0 </span>; <span class="kw">pub const </span>MRUBY_PATCHLEVEL : i32 = - <span class="number">1 </span>; <span class="kw">pub const </span>MRUBY_PATCHLEVEL_STR : &amp; [u8 ; <span class="number">1</span>] = <span class="string">b"\0" </span>; <span class="kw">pub const </span>MRUBY_RELEASE_NO : u32 = <span class="number">30200 </span>; <span class="kw">pub const </span>MRUBY_RELEASE_YEAR : u32 = <span class="number">2023 </span>; <span class="kw">pub const </span>MRUBY_RELEASE_MONTH : u32 = <span class="number">2 </span>; <span class="kw">pub const </span>MRUBY_RELEASE_DAY : u32 = <span class="number">24 </span>; <span class="kw">pub const </span>MRUBY_BIRTH_YEAR : u32 = <span class="number">2010 </span>; <span class="kw">pub const </span>MRUBY_AUTHOR : &amp; [u8 ; <span class="number">17</span>] = <span class="string">b"mruby developers\0" </span>; <span class="kw">pub const </span>MRB_FIXED_STATE_ATEXIT_STACK_SIZE : u32 = <span class="number">5 </span>; <span class="kw">pub const </span>MRB_METHOD_CACHE_SIZE : u32 = <span class="number">256 </span>; <span class="kw">pub const </span>MRB_ARY_EMBED_LEN_MAX : u32 = <span class="number">0 </span>; <span class="kw">pub const </span>MRB_ARY_SHARED : u32 = <span class="number">256 </span>; <span class="kw">pub const </span>MRB_FL_CLASS_IS_PREPENDED : u32 = <span class="number">524288 </span>; <span class="kw">pub const </span>MRB_FL_CLASS_IS_ORIGIN : u32 = <span class="number">262144 </span>; <span class="kw">pub const </span>MRB_FL_CLASS_IS_INHERITED : u32 = <span class="number">131072 </span>; <span class="kw">pub const </span>MRB_INSTANCE_TT_MASK : u32 = <span class="number">255 </span>; <span class="kw">pub const </span>MRB_PARSER_TOKBUF_MAX : u32 = <span class="number">65534 </span>; <span class="kw">pub const </span>MRB_PARSER_TOKBUF_SIZE : u32 = <span class="number">256 </span>; <span class="kw">pub const </span>MRB_ISEQ_NO_FREE : u32 = <span class="number">1 </span>; <span class="kw">pub const </span>MRB_IREP_NO_FREE : u32 = <span class="number">2 </span>; <span class="kw">pub const </span>MRB_IREP_STATIC : u32 = <span class="number">3 </span>; <span class="kw">pub const </span>MRB_DUMP_DEBUG_INFO : u32 = <span class="number">1 </span>; <span class="kw">pub const </span>MRB_DUMP_STATIC : u32 = <span class="number">2 </span>; <span class="kw">pub const </span>MRB_DUMP_OK : u32 = <span class="number">0 </span>; <span class="kw">pub const </span>MRB_DUMP_GENERAL_FAILURE : i32 = - <span class="number">1 </span>; <span class="kw">pub const </span>MRB_DUMP_WRITE_FAULT : i32 = - <span class="number">2 </span>; <span class="kw">pub const </span>MRB_DUMP_READ_FAULT : i32 = - <span class="number">3 </span>; <span class="kw">pub const </span>MRB_DUMP_INVALID_FILE_HEADER : i32 = - <span class="number">4 </span>; <span class="kw">pub const </span>MRB_DUMP_INVALID_IREP : i32 = - <span class="number">5 </span>; <span class="kw">pub const </span>MRB_DUMP_INVALID_ARGUMENT : i32 = - <span class="number">6 </span>; <span class="kw">pub const </span>MRB_DUMP_NULL_SYM_LEN : u32 = <span class="number">65535 </span>; <span class="kw">pub const </span>MRB_DUMP_DEFAULT_STR_LEN : u32 = <span class="number">128 </span>; <span class="kw">pub const </span>MRB_EXC_EXIT : u32 = <span class="number">65536 </span>; <span class="kw">pub const </span>MRB_HASH_IB_BIT_BIT : u32 = <span class="number">5 </span>; <span class="kw">pub const </span>MRB_HASH_AR_EA_CAPA_BIT : u32 = <span class="number">5 </span>; <span class="kw">pub const </span>MRB_HASH_IB_BIT_SHIFT : u32 = <span class="number">0 </span>; <span class="kw">pub const </span>MRB_HASH_AR_EA_CAPA_SHIFT : u32 = <span class="number">0 </span>; <span class="kw">pub const </span>MRB_HASH_AR_EA_N_USED_SHIFT : u32 = <span class="number">5 </span>; <span class="kw">pub const </span>MRB_HASH_SIZE_FLAGS_SHIFT : u32 = <span class="number">10 </span>; <span class="kw">pub const </span>MRB_HASH_IB_BIT_MASK : u32 = <span class="number">31 </span>; <span class="kw">pub const </span>MRB_HASH_AR_EA_CAPA_MASK : u32 = <span class="number">31 </span>; <span class="kw">pub const </span>MRB_HASH_AR_EA_N_USED_MASK : u32 = <span class="number">992 </span>; <span class="kw">pub const </span>MRB_HASH_DEFAULT : u32 = <span class="number">1024 </span>; <span class="kw">pub const </span>MRB_HASH_PROC_DEFAULT : u32 = <span class="number">2048 </span>; <span class="kw">pub const </span>MRB_HASH_HT : u32 = <span class="number">4096 </span>; <span class="kw">pub const </span>MRB_ENV_CLOSED : u32 = <span class="number">1048576 </span>; <span class="kw">pub const </span>MRB_PROC_CFUNC_FL : u32 = <span class="number">128 </span>; <span class="kw">pub const </span>MRB_PROC_STRICT : u32 = <span class="number">256 </span>; <span class="kw">pub const </span>MRB_PROC_ORPHAN : u32 = <span class="number">512 </span>; <span class="kw">pub const </span>MRB_PROC_ENVSET : u32 = <span class="number">1024 </span>; <span class="kw">pub const </span>MRB_PROC_SCOPE : u32 = <span class="number">2048 </span>; <span class="kw">pub const </span>MRB_PROC_NOARG : u32 = <span class="number">4096 </span>; <span class="kw">pub const </span>MRB_METHOD_FUNC_FL : u32 = <span class="number">1 </span>; <span class="kw">pub const </span>MRB_METHOD_NOARG_FL : u32 = <span class="number">2 </span>; <span class="kw">pub const </span>MRB_STR_SHARED : u32 = <span class="number">1 </span>; <span class="kw">pub const </span>MRB_STR_FSHARED : u32 = <span class="number">2 </span>; <span class="kw">pub const </span>MRB_STR_NOFREE : u32 = <span class="number">4 </span>; <span class="kw">pub const </span>MRB_STR_EMBED : u32 = <span class="number">8 </span>; <span class="kw">pub const </span>MRB_STR_ASCII : u32 = <span class="number">16 </span>; <span class="kw">pub const </span>MRB_STR_EMBED_LEN_SHIFT : u32 = <span class="number">6 </span>; <span class="kw">pub const </span>MRB_STR_EMBED_LEN_BIT : u32 = <span class="number">5 </span>; <span class="kw">pub const </span>MRB_STR_EMBED_LEN_MASK : u32 = <span class="number">1984 </span>; <span class="kw">pub const </span>MRB_STR_TYPE_MASK : u32 = <span class="number">15 </span>; <span class="kw">pub type </span>va_list = __builtin_va_list ; # [repr (C)] # [derive (Debug , Copy , Clone)] <span class="kw">pub struct </span>__sigset_t { <span class="kw">pub </span>__val : [:: std :: os :: raw :: c_ulong ; <span class="number">16usize</span>] , } # [test] <span class="kw">fn </span>bindgen_test_layout___sigset_t () { <span class="kw">const </span>UNINIT : :: std :: mem :: MaybeUninit &lt; __sigset_t &gt; = :: std :: mem :: MaybeUninit :: uninit () ; <span class="kw">let </span>ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: &lt; __sigset_t &gt; () , <span class="number">128usize </span>, concat ! (<span class="string">"Size of: " </span>, stringify ! (__sigset_t))) ; assert_eq ! (:: std :: mem :: align_of :: &lt; __sigset_t &gt; () , <span class="number">8usize </span>, concat ! (<span class="string">"Alignment of " </span>, stringify ! (__sigset_t))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . __val) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">0usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (__sigset_t) , <span class="string">"::" </span>, stringify ! (__val))) ; } <span class="kw">pub type </span>mrb_sym = u32 ; <span class="kw">pub type </span>mrb_bool = bool ; <span class="kw">pub type </span>mrb_int = i64 ; <span class="kw">pub type </span>mrb_uint = u64 ; <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_read_int (p : * <span class="kw">const </span>:: std :: os :: raw :: c_char , e : * <span class="kw">const </span>:: std :: os :: raw :: c_char , endp : * <span class="kw-2">mut </span>* <span class="kw-2">mut </span>:: std :: os :: raw :: c_char , np : * <span class="kw-2">mut </span>mrb_int) -&gt; mrb_bool ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_int_read (arg1 : * <span class="kw">const </span>:: std :: os :: raw :: c_char , arg2 : * <span class="kw">const </span>:: std :: os :: raw :: c_char , arg3 : * <span class="kw-2">mut </span>* <span class="kw-2">mut </span>:: std :: os :: raw :: c_char) -&gt; mrb_int ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_read_float (p : * <span class="kw">const </span>:: std :: os :: raw :: c_char , endp : * <span class="kw-2">mut </span>* <span class="kw-2">mut </span>:: std :: os :: raw :: c_char , fp : * <span class="kw-2">mut </span>f64) -&gt; mrb_bool ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_float_read (p : * <span class="kw">const </span>:: std :: os :: raw :: c_char , endp : * <span class="kw-2">mut </span>* <span class="kw-2">mut </span>:: std :: os :: raw :: c_char) -&gt; f64 ; } <span class="kw">pub type </span>mrb_float = f64 ; # [repr (u32)] # [derive (Debug , Copy , Clone , Hash , PartialEq , Eq)] <span class="kw">pub enum </span>mrb_vtype { MRB_TT_FALSE = <span class="number">0 </span>, MRB_TT_TRUE = <span class="number">1 </span>, MRB_TT_SYMBOL = <span class="number">2 </span>, MRB_TT_UNDEF = <span class="number">3 </span>, MRB_TT_FREE = <span class="number">4 </span>, MRB_TT_FLOAT = <span class="number">5 </span>, MRB_TT_INTEGER = <span class="number">6 </span>, MRB_TT_CPTR = <span class="number">7 </span>, MRB_TT_OBJECT = <span class="number">8 </span>, MRB_TT_CLASS = <span class="number">9 </span>, MRB_TT_MODULE = <span class="number">10 </span>, MRB_TT_ICLASS = <span class="number">11 </span>, MRB_TT_SCLASS = <span class="number">12 </span>, MRB_TT_PROC = <span class="number">13 </span>, MRB_TT_ARRAY = <span class="number">14 </span>, MRB_TT_HASH = <span class="number">15 </span>, MRB_TT_STRING = <span class="number">16 </span>, MRB_TT_RANGE = <span class="number">17 </span>, MRB_TT_EXCEPTION = <span class="number">18 </span>, MRB_TT_ENV = <span class="number">19 </span>, MRB_TT_CDATA = <span class="number">20 </span>, MRB_TT_FIBER = <span class="number">21 </span>, MRB_TT_STRUCT = <span class="number">22 </span>, MRB_TT_ISTRUCT = <span class="number">23 </span>, MRB_TT_BREAK = <span class="number">24 </span>, MRB_TT_COMPLEX = <span class="number">25 </span>, MRB_TT_RATIONAL = <span class="number">26 </span>, MRB_TT_BIGINT = <span class="number">27 </span>, MRB_TT_MAXDEFINE = <span class="number">28 </span>, } # [repr (C)] # [derive (Debug , Copy , Clone)] <span class="kw">pub struct </span>RBasic { <span class="kw">pub </span>c : * <span class="kw-2">mut </span>RClass , <span class="kw">pub </span>gcnext : * <span class="kw-2">mut </span>RBasic , <span class="kw">pub </span>_bitfield_align_1 : [u32 ; <span class="number">0</span>] , <span class="kw">pub </span>_bitfield_1 : __BindgenBitfieldUnit &lt; [u8 ; <span class="number">4usize</span>] &gt; , <span class="kw">pub </span>__bindgen_padding_0 : u32 , } # [test] <span class="kw">fn </span>bindgen_test_layout_RBasic () { <span class="kw">const </span>UNINIT : :: std :: mem :: MaybeUninit &lt; RBasic &gt; = :: std :: mem :: MaybeUninit :: uninit () ; <span class="kw">let </span>ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: &lt; RBasic &gt; () , <span class="number">24usize </span>, concat ! (<span class="string">"Size of: " </span>, stringify ! (RBasic))) ; assert_eq ! (:: std :: mem :: align_of :: &lt; RBasic &gt; () , <span class="number">8usize </span>, concat ! (<span class="string">"Alignment of " </span>, stringify ! (RBasic))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . c) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">0usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (RBasic) , <span class="string">"::" </span>, stringify ! (c))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . gcnext) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">8usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (RBasic) , <span class="string">"::" </span>, stringify ! (gcnext))) ; } <span class="kw">impl </span>RBasic { # [inline] <span class="kw">pub fn </span>tt (&amp; <span class="self">self</span>) -&gt; mrb_vtype { <span class="kw">unsafe </span>{ :: std :: mem :: transmute (<span class="self">self </span>. _bitfield_1 . get (<span class="number">0usize </span>, <span class="number">8u8</span>) <span class="kw">as </span>u32) } } # [inline] <span class="kw">pub fn </span>set_tt (&amp; <span class="kw-2">mut </span><span class="self">self </span>, val : mrb_vtype) { <span class="kw">unsafe </span>{ <span class="kw">let </span>val : u32 = :: std :: mem :: transmute (val) ; <span class="self">self </span>. _bitfield_1 . set (<span class="number">0usize </span>, <span class="number">8u8 </span>, val <span class="kw">as </span>u64) } } # [inline] <span class="kw">pub fn </span>color (&amp; <span class="self">self</span>) -&gt; u32 { <span class="kw">unsafe </span>{ :: std :: mem :: transmute (<span class="self">self </span>. _bitfield_1 . get (<span class="number">8usize </span>, <span class="number">3u8</span>) <span class="kw">as </span>u32) } } # [inline] <span class="kw">pub fn </span>set_color (&amp; <span class="kw-2">mut </span><span class="self">self </span>, val : u32) { <span class="kw">unsafe </span>{ <span class="kw">let </span>val : u32 = :: std :: mem :: transmute (val) ; <span class="self">self </span>. _bitfield_1 . set (<span class="number">8usize </span>, <span class="number">3u8 </span>, val <span class="kw">as </span>u64) } } # [inline] <span class="kw">pub fn </span>flags (&amp; <span class="self">self</span>) -&gt; u32 { <span class="kw">unsafe </span>{ :: std :: mem :: transmute (<span class="self">self </span>. _bitfield_1 . get (<span class="number">11usize </span>, <span class="number">21u8</span>) <span class="kw">as </span>u32) } } # [inline] <span class="kw">pub fn </span>set_flags (&amp; <span class="kw-2">mut </span><span class="self">self </span>, val : u32) { <span class="kw">unsafe </span>{ <span class="kw">let </span>val : u32 = :: std :: mem :: transmute (val) ; <span class="self">self </span>. _bitfield_1 . set (<span class="number">11usize </span>, <span class="number">21u8 </span>, val <span class="kw">as </span>u64) } } # [inline] <span class="kw">pub fn </span>new_bitfield_1 (tt : mrb_vtype , color : u32 , flags : u32) -&gt; __BindgenBitfieldUnit &lt; [u8 ; <span class="number">4usize</span>] &gt; { <span class="kw">let </span><span class="kw-2">mut </span>__bindgen_bitfield_unit : __BindgenBitfieldUnit &lt; [u8 ; <span class="number">4usize</span>] &gt; = Default :: default () ; __bindgen_bitfield_unit . set (<span class="number">0usize </span>, <span class="number">8u8 </span>, { <span class="kw">let </span>tt : u32 = <span class="kw">unsafe </span>{ :: std :: mem :: transmute (tt) } ; tt <span class="kw">as </span>u64 }) ; __bindgen_bitfield_unit . set (<span class="number">8usize </span>, <span class="number">3u8 </span>, { <span class="kw">let </span>color : u32 = <span class="kw">unsafe </span>{ :: std :: mem :: transmute (color) } ; color <span class="kw">as </span>u64 }) ; __bindgen_bitfield_unit . set (<span class="number">11usize </span>, <span class="number">21u8 </span>, { <span class="kw">let </span>flags : u32 = <span class="kw">unsafe </span>{ :: std :: mem :: transmute (flags) } ; flags <span class="kw">as </span>u64 }) ; __bindgen_bitfield_unit } } # [repr (C)] # [derive (Debug , Copy , Clone)] <span class="kw">pub struct </span>RObject { <span class="kw">pub </span>c : * <span class="kw-2">mut </span>RClass , <span class="kw">pub </span>gcnext : * <span class="kw-2">mut </span>RBasic , <span class="kw">pub </span>_bitfield_align_1 : [u32 ; <span class="number">0</span>] , <span class="kw">pub </span>_bitfield_1 : __BindgenBitfieldUnit &lt; [u8 ; <span class="number">4usize</span>] &gt; , <span class="kw">pub </span>iv : * <span class="kw-2">mut </span>iv_tbl , } # [test] <span class="kw">fn </span>bindgen_test_layout_RObject () { <span class="kw">const </span>UNINIT : :: std :: mem :: MaybeUninit &lt; RObject &gt; = :: std :: mem :: MaybeUninit :: uninit () ; <span class="kw">let </span>ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: &lt; RObject &gt; () , <span class="number">32usize </span>, concat ! (<span class="string">"Size of: " </span>, stringify ! (RObject))) ; assert_eq ! (:: std :: mem :: align_of :: &lt; RObject &gt; () , <span class="number">8usize </span>, concat ! (<span class="string">"Alignment of " </span>, stringify ! (RObject))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . c) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">0usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (RObject) , <span class="string">"::" </span>, stringify ! (c))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . gcnext) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">8usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (RObject) , <span class="string">"::" </span>, stringify ! (gcnext))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . iv) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">24usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (RObject) , <span class="string">"::" </span>, stringify ! (iv))) ; } <span class="kw">impl </span>RObject { # [inline] <span class="kw">pub fn </span>tt (&amp; <span class="self">self</span>) -&gt; mrb_vtype { <span class="kw">unsafe </span>{ :: std :: mem :: transmute (<span class="self">self </span>. _bitfield_1 . get (<span class="number">0usize </span>, <span class="number">8u8</span>) <span class="kw">as </span>u32) } } # [inline] <span class="kw">pub fn </span>set_tt (&amp; <span class="kw-2">mut </span><span class="self">self </span>, val : mrb_vtype) { <span class="kw">unsafe </span>{ <span class="kw">let </span>val : u32 = :: std :: mem :: transmute (val) ; <span class="self">self </span>. _bitfield_1 . set (<span class="number">0usize </span>, <span class="number">8u8 </span>, val <span class="kw">as </span>u64) } } # [inline] <span class="kw">pub fn </span>color (&amp; <span class="self">self</span>) -&gt; u32 { <span class="kw">unsafe </span>{ :: std :: mem :: transmute (<span class="self">self </span>. _bitfield_1 . get (<span class="number">8usize </span>, <span class="number">3u8</span>) <span class="kw">as </span>u32) } } # [inline] <span class="kw">pub fn </span>set_color (&amp; <span class="kw-2">mut </span><span class="self">self </span>, val : u32) { <span class="kw">unsafe </span>{ <span class="kw">let </span>val : u32 = :: std :: mem :: transmute (val) ; <span class="self">self </span>. _bitfield_1 . set (<span class="number">8usize </span>, <span class="number">3u8 </span>, val <span class="kw">as </span>u64) } } # [inline] <span class="kw">pub fn </span>flags (&amp; <span class="self">self</span>) -&gt; u32 { <span class="kw">unsafe </span>{ :: std :: mem :: transmute (<span class="self">self </span>. _bitfield_1 . get (<span class="number">11usize </span>, <span class="number">21u8</span>) <span class="kw">as </span>u32) } } # [inline] <span class="kw">pub fn </span>set_flags (&amp; <span class="kw-2">mut </span><span class="self">self </span>, val : u32) { <span class="kw">unsafe </span>{ <span class="kw">let </span>val : u32 = :: std :: mem :: transmute (val) ; <span class="self">self </span>. _bitfield_1 . set (<span class="number">11usize </span>, <span class="number">21u8 </span>, val <span class="kw">as </span>u64) } } # [inline] <span class="kw">pub fn </span>new_bitfield_1 (tt : mrb_vtype , color : u32 , flags : u32) -&gt; __BindgenBitfieldUnit &lt; [u8 ; <span class="number">4usize</span>] &gt; { <span class="kw">let </span><span class="kw-2">mut </span>__bindgen_bitfield_unit : __BindgenBitfieldUnit &lt; [u8 ; <span class="number">4usize</span>] &gt; = Default :: default () ; __bindgen_bitfield_unit . set (<span class="number">0usize </span>, <span class="number">8u8 </span>, { <span class="kw">let </span>tt : u32 = <span class="kw">unsafe </span>{ :: std :: mem :: transmute (tt) } ; tt <span class="kw">as </span>u64 }) ; __bindgen_bitfield_unit . set (<span class="number">8usize </span>, <span class="number">3u8 </span>, { <span class="kw">let </span>color : u32 = <span class="kw">unsafe </span>{ :: std :: mem :: transmute (color) } ; color <span class="kw">as </span>u64 }) ; __bindgen_bitfield_unit . set (<span class="number">11usize </span>, <span class="number">21u8 </span>, { <span class="kw">let </span>flags : u32 = <span class="kw">unsafe </span>{ :: std :: mem :: transmute (flags) } ; flags <span class="kw">as </span>u64 }) ; __bindgen_bitfield_unit } } # [repr (C)] # [derive (Debug , Copy , Clone)] <span class="kw">pub struct </span>RFiber { <span class="kw">pub </span>c : * <span class="kw-2">mut </span>RClass , <span class="kw">pub </span>gcnext : * <span class="kw-2">mut </span>RBasic , <span class="kw">pub </span>_bitfield_align_1 : [u32 ; <span class="number">0</span>] , <span class="kw">pub </span>_bitfield_1 : __BindgenBitfieldUnit &lt; [u8 ; <span class="number">4usize</span>] &gt; , <span class="kw">pub </span>cxt : * <span class="kw-2">mut </span>mrb_context , } # [test] <span class="kw">fn </span>bindgen_test_layout_RFiber () { <span class="kw">const </span>UNINIT : :: std :: mem :: MaybeUninit &lt; RFiber &gt; = :: std :: mem :: MaybeUninit :: uninit () ; <span class="kw">let </span>ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: &lt; RFiber &gt; () , <span class="number">32usize </span>, concat ! (<span class="string">"Size of: " </span>, stringify ! (RFiber))) ; assert_eq ! (:: std :: mem :: align_of :: &lt; RFiber &gt; () , <span class="number">8usize </span>, concat ! (<span class="string">"Alignment of " </span>, stringify ! (RFiber))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . c) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">0usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (RFiber) , <span class="string">"::" </span>, stringify ! (c))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . gcnext) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">8usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (RFiber) , <span class="string">"::" </span>, stringify ! (gcnext))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . cxt) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">24usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (RFiber) , <span class="string">"::" </span>, stringify ! (cxt))) ; } <span class="kw">impl </span>RFiber { # [inline] <span class="kw">pub fn </span>tt (&amp; <span class="self">self</span>) -&gt; mrb_vtype { <span class="kw">unsafe </span>{ :: std :: mem :: transmute (<span class="self">self </span>. _bitfield_1 . get (<span class="number">0usize </span>, <span class="number">8u8</span>) <span class="kw">as </span>u32) } } # [inline] <span class="kw">pub fn </span>set_tt (&amp; <span class="kw-2">mut </span><span class="self">self </span>, val : mrb_vtype) { <span class="kw">unsafe </span>{ <span class="kw">let </span>val : u32 = :: std :: mem :: transmute (val) ; <span class="self">self </span>. _bitfield_1 . set (<span class="number">0usize </span>, <span class="number">8u8 </span>, val <span class="kw">as </span>u64) } } # [inline] <span class="kw">pub fn </span>color (&amp; <span class="self">self</span>) -&gt; u32 { <span class="kw">unsafe </span>{ :: std :: mem :: transmute (<span class="self">self </span>. _bitfield_1 . get (<span class="number">8usize </span>, <span class="number">3u8</span>) <span class="kw">as </span>u32) } } # [inline] <span class="kw">pub fn </span>set_color (&amp; <span class="kw-2">mut </span><span class="self">self </span>, val : u32) { <span class="kw">unsafe </span>{ <span class="kw">let </span>val : u32 = :: std :: mem :: transmute (val) ; <span class="self">self </span>. _bitfield_1 . set (<span class="number">8usize </span>, <span class="number">3u8 </span>, val <span class="kw">as </span>u64) } } # [inline] <span class="kw">pub fn </span>flags (&amp; <span class="self">self</span>) -&gt; u32 { <span class="kw">unsafe </span>{ :: std :: mem :: transmute (<span class="self">self </span>. _bitfield_1 . get (<span class="number">11usize </span>, <span class="number">21u8</span>) <span class="kw">as </span>u32) } } # [inline] <span class="kw">pub fn </span>set_flags (&amp; <span class="kw-2">mut </span><span class="self">self </span>, val : u32) { <span class="kw">unsafe </span>{ <span class="kw">let </span>val : u32 = :: std :: mem :: transmute (val) ; <span class="self">self </span>. _bitfield_1 . set (<span class="number">11usize </span>, <span class="number">21u8 </span>, val <span class="kw">as </span>u64) } } # [inline] <span class="kw">pub fn </span>new_bitfield_1 (tt : mrb_vtype , color : u32 , flags : u32) -&gt; __BindgenBitfieldUnit &lt; [u8 ; <span class="number">4usize</span>] &gt; { <span class="kw">let </span><span class="kw-2">mut </span>__bindgen_bitfield_unit : __BindgenBitfieldUnit &lt; [u8 ; <span class="number">4usize</span>] &gt; = Default :: default () ; __bindgen_bitfield_unit . set (<span class="number">0usize </span>, <span class="number">8u8 </span>, { <span class="kw">let </span>tt : u32 = <span class="kw">unsafe </span>{ :: std :: mem :: transmute (tt) } ; tt <span class="kw">as </span>u64 }) ; __bindgen_bitfield_unit . set (<span class="number">8usize </span>, <span class="number">3u8 </span>, { <span class="kw">let </span>color : u32 = <span class="kw">unsafe </span>{ :: std :: mem :: transmute (color) } ; color <span class="kw">as </span>u64 }) ; __bindgen_bitfield_unit . set (<span class="number">11usize </span>, <span class="number">21u8 </span>, { <span class="kw">let </span>flags : u32 = <span class="kw">unsafe </span>{ :: std :: mem :: transmute (flags) } ; flags <span class="kw">as </span>u64 }) ; __bindgen_bitfield_unit } } # [repr (C)] # [derive (Copy , Clone)] <span class="kw">pub union </span>mrb_value_union { <span class="kw">pub </span>f : mrb_float , <span class="kw">pub </span>p : * <span class="kw-2">mut </span>:: std :: os :: raw :: c_void , <span class="kw">pub </span>i : mrb_int , <span class="kw">pub </span>sym : mrb_sym , } # [test] <span class="kw">fn </span>bindgen_test_layout_mrb_value_union () { <span class="kw">const </span>UNINIT : :: std :: mem :: MaybeUninit &lt; mrb_value_union &gt; = :: std :: mem :: MaybeUninit :: uninit () ; <span class="kw">let </span>ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: &lt; mrb_value_union &gt; () , <span class="number">8usize </span>, concat ! (<span class="string">"Size of: " </span>, stringify ! (mrb_value_union))) ; assert_eq ! (:: std :: mem :: align_of :: &lt; mrb_value_union &gt; () , <span class="number">8usize </span>, concat ! (<span class="string">"Alignment of " </span>, stringify ! (mrb_value_union))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . f) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">0usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (mrb_value_union) , <span class="string">"::" </span>, stringify ! (f))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . p) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">0usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (mrb_value_union) , <span class="string">"::" </span>, stringify ! (p))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . i) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">0usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (mrb_value_union) , <span class="string">"::" </span>, stringify ! (i))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . sym) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">0usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (mrb_value_union) , <span class="string">"::" </span>, stringify ! (sym))) ; } # [repr (C)] # [derive (Copy , Clone)] <span class="kw">pub struct </span>mrb_value { <span class="kw">pub </span>value : mrb_value_union , <span class="kw">pub </span>tt : mrb_vtype , } # [test] <span class="kw">fn </span>bindgen_test_layout_mrb_value () { <span class="kw">const </span>UNINIT : :: std :: mem :: MaybeUninit &lt; mrb_value &gt; = :: std :: mem :: MaybeUninit :: uninit () ; <span class="kw">let </span>ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: &lt; mrb_value &gt; () , <span class="number">16usize </span>, concat ! (<span class="string">"Size of: " </span>, stringify ! (mrb_value))) ; assert_eq ! (:: std :: mem :: align_of :: &lt; mrb_value &gt; () , <span class="number">8usize </span>, concat ! (<span class="string">"Alignment of " </span>, stringify ! (mrb_value))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . value) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">0usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (mrb_value) , <span class="string">"::" </span>, stringify ! (value))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . tt) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">8usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (mrb_value) , <span class="string">"::" </span>, stringify ! (tt))) ; } <span class="kw">pub type </span>mrb_ssize = mrb_int ; <span class="kw">pub type </span>mrb_each_object_callback = :: std :: option :: <span class="prelude-ty">Option </span>&lt; <span class="kw">unsafe extern </span><span class="string">"C" </span><span class="kw">fn </span>(mrb : * <span class="kw-2">mut </span>mrb_state , obj : * <span class="kw-2">mut </span>RBasic , data : * <span class="kw-2">mut </span>:: std :: os :: raw :: c_void) -&gt; :: std :: os :: raw :: c_int &gt; ; <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_objspace_each_objects (mrb : * <span class="kw-2">mut </span>mrb_state , callback : mrb_each_object_callback , data : * <span class="kw-2">mut </span>:: std :: os :: raw :: c_void) ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_objspace_page_slot_size () -&gt; usize ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_free_context (mrb : * <span class="kw-2">mut </span>mrb_state , c : * <span class="kw-2">mut </span>mrb_context) ; } # [repr (u32)] # [derive (Debug , Copy , Clone , Hash , PartialEq , Eq)] <span class="kw">pub enum </span>mrb_gc_state { MRB_GC_STATE_ROOT = <span class="number">0 </span>, MRB_GC_STATE_MARK = <span class="number">1 </span>, MRB_GC_STATE_SWEEP = <span class="number">2 </span>, } # [repr (C)] # [derive (Debug , Copy , Clone)] <span class="kw">pub struct </span>mrb_heap_page { <span class="kw">pub </span>freelist : * <span class="kw-2">mut </span>RBasic , <span class="kw">pub </span>prev : * <span class="kw-2">mut </span>mrb_heap_page , <span class="kw">pub </span>next : * <span class="kw-2">mut </span>mrb_heap_page , <span class="kw">pub </span>free_next : * <span class="kw-2">mut </span>mrb_heap_page , <span class="kw">pub </span>free_prev : * <span class="kw-2">mut </span>mrb_heap_page , <span class="kw">pub </span>_bitfield_align_1 : [u8 ; <span class="number">0</span>] , <span class="kw">pub </span>_bitfield_1 : __BindgenBitfieldUnit &lt; [u8 ; <span class="number">1usize</span>] &gt; , <span class="kw">pub </span>__bindgen_padding_0 : [u8 ; <span class="number">7usize</span>] , } # [test] <span class="kw">fn </span>bindgen_test_layout_mrb_heap_page () { <span class="kw">const </span>UNINIT : :: std :: mem :: MaybeUninit &lt; mrb_heap_page &gt; = :: std :: mem :: MaybeUninit :: uninit () ; <span class="kw">let </span>ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: &lt; mrb_heap_page &gt; () , <span class="number">48usize </span>, concat ! (<span class="string">"Size of: " </span>, stringify ! (mrb_heap_page))) ; assert_eq ! (:: std :: mem :: align_of :: &lt; mrb_heap_page &gt; () , <span class="number">8usize </span>, concat ! (<span class="string">"Alignment of " </span>, stringify ! (mrb_heap_page))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . freelist) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">0usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (mrb_heap_page) , <span class="string">"::" </span>, stringify ! (freelist))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . prev) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">8usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (mrb_heap_page) , <span class="string">"::" </span>, stringify ! (prev))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . next) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">16usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (mrb_heap_page) , <span class="string">"::" </span>, stringify ! (next))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . free_next) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">24usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (mrb_heap_page) , <span class="string">"::" </span>, stringify ! (free_next))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . free_prev) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">32usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (mrb_heap_page) , <span class="string">"::" </span>, stringify ! (free_prev))) ; } <span class="kw">impl </span>mrb_heap_page { # [inline] <span class="kw">pub fn </span>old (&amp; <span class="self">self</span>) -&gt; mrb_bool { <span class="kw">unsafe </span>{ :: std :: mem :: transmute (<span class="self">self </span>. _bitfield_1 . get (<span class="number">0usize </span>, <span class="number">1u8</span>) <span class="kw">as </span>u8) } } # [inline] <span class="kw">pub fn </span>set_old (&amp; <span class="kw-2">mut </span><span class="self">self </span>, val : mrb_bool) { <span class="kw">unsafe </span>{ <span class="kw">let </span>val : u8 = :: std :: mem :: transmute (val) ; <span class="self">self </span>. _bitfield_1 . set (<span class="number">0usize </span>, <span class="number">1u8 </span>, val <span class="kw">as </span>u64) } } # [inline] <span class="kw">pub fn </span>new_bitfield_1 (old : mrb_bool) -&gt; __BindgenBitfieldUnit &lt; [u8 ; <span class="number">1usize</span>] &gt; { <span class="kw">let </span><span class="kw-2">mut </span>__bindgen_bitfield_unit : __BindgenBitfieldUnit &lt; [u8 ; <span class="number">1usize</span>] &gt; = Default :: default () ; __bindgen_bitfield_unit . set (<span class="number">0usize </span>, <span class="number">1u8 </span>, { <span class="kw">let </span>old : u8 = <span class="kw">unsafe </span>{ :: std :: mem :: transmute (old) } ; old <span class="kw">as </span>u64 }) ; __bindgen_bitfield_unit } } # [repr (C)] # [derive (Debug , Copy , Clone)] <span class="kw">pub struct </span>mrb_gc { <span class="kw">pub </span>heaps : * <span class="kw-2">mut </span>mrb_heap_page , <span class="kw">pub </span>sweeps : * <span class="kw-2">mut </span>mrb_heap_page , <span class="kw">pub </span>free_heaps : * <span class="kw-2">mut </span>mrb_heap_page , <span class="kw">pub </span>live : usize , <span class="kw">pub </span>arena : * <span class="kw-2">mut </span>* <span class="kw-2">mut </span>RBasic , <span class="kw">pub </span>arena_capa : :: std :: os :: raw :: c_int , <span class="kw">pub </span>arena_idx : :: std :: os :: raw :: c_int , <span class="kw">pub </span>state : mrb_gc_state , <span class="kw">pub </span>current_white_part : :: std :: os :: raw :: c_int , <span class="kw">pub </span>gray_list : * <span class="kw-2">mut </span>RBasic , <span class="kw">pub </span>atomic_gray_list : * <span class="kw-2">mut </span>RBasic , <span class="kw">pub </span>live_after_mark : usize , <span class="kw">pub </span>threshold : usize , <span class="kw">pub </span>interval_ratio : :: std :: os :: raw :: c_int , <span class="kw">pub </span>step_ratio : :: std :: os :: raw :: c_int , <span class="kw">pub </span>_bitfield_align_1 : [u8 ; <span class="number">0</span>] , <span class="kw">pub </span>_bitfield_1 : __BindgenBitfieldUnit &lt; [u8 ; <span class="number">1usize</span>] &gt; , <span class="kw">pub </span>majorgc_old_threshold : usize , } # [test] <span class="kw">fn </span>bindgen_test_layout_mrb_gc () { <span class="kw">const </span>UNINIT : :: std :: mem :: MaybeUninit &lt; mrb_gc &gt; = :: std :: mem :: MaybeUninit :: uninit () ; <span class="kw">let </span>ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: &lt; mrb_gc &gt; () , <span class="number">112usize </span>, concat ! (<span class="string">"Size of: " </span>, stringify ! (mrb_gc))) ; assert_eq ! (:: std :: mem :: align_of :: &lt; mrb_gc &gt; () , <span class="number">8usize </span>, concat ! (<span class="string">"Alignment of " </span>, stringify ! (mrb_gc))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . heaps) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">0usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (mrb_gc) , <span class="string">"::" </span>, stringify ! (heaps))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . sweeps) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">8usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (mrb_gc) , <span class="string">"::" </span>, stringify ! (sweeps))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . free_heaps) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">16usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (mrb_gc) , <span class="string">"::" </span>, stringify ! (free_heaps))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . live) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">24usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (mrb_gc) , <span class="string">"::" </span>, stringify ! (live))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . arena) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">32usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (mrb_gc) , <span class="string">"::" </span>, stringify ! (arena))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . arena_capa) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">40usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (mrb_gc) , <span class="string">"::" </span>, stringify ! (arena_capa))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . arena_idx) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">44usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (mrb_gc) , <span class="string">"::" </span>, stringify ! (arena_idx))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . state) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">48usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (mrb_gc) , <span class="string">"::" </span>, stringify ! (state))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . current_white_part) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">52usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (mrb_gc) , <span class="string">"::" </span>, stringify ! (current_white_part))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . gray_list) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">56usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (mrb_gc) , <span class="string">"::" </span>, stringify ! (gray_list))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . atomic_gray_list) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">64usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (mrb_gc) , <span class="string">"::" </span>, stringify ! (atomic_gray_list))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . live_after_mark) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">72usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (mrb_gc) , <span class="string">"::" </span>, stringify ! (live_after_mark))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . threshold) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">80usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (mrb_gc) , <span class="string">"::" </span>, stringify ! (threshold))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . interval_ratio) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">88usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (mrb_gc) , <span class="string">"::" </span>, stringify ! (interval_ratio))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . step_ratio) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">92usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (mrb_gc) , <span class="string">"::" </span>, stringify ! (step_ratio))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . majorgc_old_threshold) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">104usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (mrb_gc) , <span class="string">"::" </span>, stringify ! (majorgc_old_threshold))) ; } <span class="kw">impl </span>mrb_gc { # [inline] <span class="kw">pub fn </span>iterating (&amp; <span class="self">self</span>) -&gt; mrb_bool { <span class="kw">unsafe </span>{ :: std :: mem :: transmute (<span class="self">self </span>. _bitfield_1 . get (<span class="number">0usize </span>, <span class="number">1u8</span>) <span class="kw">as </span>u8) } } # [inline] <span class="kw">pub fn </span>set_iterating (&amp; <span class="kw-2">mut </span><span class="self">self </span>, val : mrb_bool) { <span class="kw">unsafe </span>{ <span class="kw">let </span>val : u8 = :: std :: mem :: transmute (val) ; <span class="self">self </span>. _bitfield_1 . set (<span class="number">0usize </span>, <span class="number">1u8 </span>, val <span class="kw">as </span>u64) } } # [inline] <span class="kw">pub fn </span>disabled (&amp; <span class="self">self</span>) -&gt; mrb_bool { <span class="kw">unsafe </span>{ :: std :: mem :: transmute (<span class="self">self </span>. _bitfield_1 . get (<span class="number">1usize </span>, <span class="number">1u8</span>) <span class="kw">as </span>u8) } } # [inline] <span class="kw">pub fn </span>set_disabled (&amp; <span class="kw-2">mut </span><span class="self">self </span>, val : mrb_bool) { <span class="kw">unsafe </span>{ <span class="kw">let </span>val : u8 = :: std :: mem :: transmute (val) ; <span class="self">self </span>. _bitfield_1 . set (<span class="number">1usize </span>, <span class="number">1u8 </span>, val <span class="kw">as </span>u64) } } # [inline] <span class="kw">pub fn </span>full (&amp; <span class="self">self</span>) -&gt; mrb_bool { <span class="kw">unsafe </span>{ :: std :: mem :: transmute (<span class="self">self </span>. _bitfield_1 . get (<span class="number">2usize </span>, <span class="number">1u8</span>) <span class="kw">as </span>u8) } } # [inline] <span class="kw">pub fn </span>set_full (&amp; <span class="kw-2">mut </span><span class="self">self </span>, val : mrb_bool) { <span class="kw">unsafe </span>{ <span class="kw">let </span>val : u8 = :: std :: mem :: transmute (val) ; <span class="self">self </span>. _bitfield_1 . set (<span class="number">2usize </span>, <span class="number">1u8 </span>, val <span class="kw">as </span>u64) } } # [inline] <span class="kw">pub fn </span>generational (&amp; <span class="self">self</span>) -&gt; mrb_bool { <span class="kw">unsafe </span>{ :: std :: mem :: transmute (<span class="self">self </span>. _bitfield_1 . get (<span class="number">3usize </span>, <span class="number">1u8</span>) <span class="kw">as </span>u8) } } # [inline] <span class="kw">pub fn </span>set_generational (&amp; <span class="kw-2">mut </span><span class="self">self </span>, val : mrb_bool) { <span class="kw">unsafe </span>{ <span class="kw">let </span>val : u8 = :: std :: mem :: transmute (val) ; <span class="self">self </span>. _bitfield_1 . set (<span class="number">3usize </span>, <span class="number">1u8 </span>, val <span class="kw">as </span>u64) } } # [inline] <span class="kw">pub fn </span>out_of_memory (&amp; <span class="self">self</span>) -&gt; mrb_bool { <span class="kw">unsafe </span>{ :: std :: mem :: transmute (<span class="self">self </span>. _bitfield_1 . get (<span class="number">4usize </span>, <span class="number">1u8</span>) <span class="kw">as </span>u8) } } # [inline] <span class="kw">pub fn </span>set_out_of_memory (&amp; <span class="kw-2">mut </span><span class="self">self </span>, val : mrb_bool) { <span class="kw">unsafe </span>{ <span class="kw">let </span>val : u8 = :: std :: mem :: transmute (val) ; <span class="self">self </span>. _bitfield_1 . set (<span class="number">4usize </span>, <span class="number">1u8 </span>, val <span class="kw">as </span>u64) } } # [inline] <span class="kw">pub fn </span>new_bitfield_1 (iterating : mrb_bool , disabled : mrb_bool , full : mrb_bool , generational : mrb_bool , out_of_memory : mrb_bool) -&gt; __BindgenBitfieldUnit &lt; [u8 ; <span class="number">1usize</span>] &gt; { <span class="kw">let </span><span class="kw-2">mut </span>__bindgen_bitfield_unit : __BindgenBitfieldUnit &lt; [u8 ; <span class="number">1usize</span>] &gt; = Default :: default () ; __bindgen_bitfield_unit . set (<span class="number">0usize </span>, <span class="number">1u8 </span>, { <span class="kw">let </span>iterating : u8 = <span class="kw">unsafe </span>{ :: std :: mem :: transmute (iterating) } ; iterating <span class="kw">as </span>u64 }) ; __bindgen_bitfield_unit . set (<span class="number">1usize </span>, <span class="number">1u8 </span>, { <span class="kw">let </span>disabled : u8 = <span class="kw">unsafe </span>{ :: std :: mem :: transmute (disabled) } ; disabled <span class="kw">as </span>u64 }) ; __bindgen_bitfield_unit . set (<span class="number">2usize </span>, <span class="number">1u8 </span>, { <span class="kw">let </span>full : u8 = <span class="kw">unsafe </span>{ :: std :: mem :: transmute (full) } ; full <span class="kw">as </span>u64 }) ; __bindgen_bitfield_unit . set (<span class="number">3usize </span>, <span class="number">1u8 </span>, { <span class="kw">let </span>generational : u8 = <span class="kw">unsafe </span>{ :: std :: mem :: transmute (generational) } ; generational <span class="kw">as </span>u64 }) ; __bindgen_bitfield_unit . set (<span class="number">4usize </span>, <span class="number">1u8 </span>, { <span class="kw">let </span>out_of_memory : u8 = <span class="kw">unsafe </span>{ :: std :: mem :: transmute (out_of_memory) } ; out_of_memory <span class="kw">as </span>u64 }) ; __bindgen_bitfield_unit } } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_object_dead_p (mrb : * <span class="kw-2">mut </span>mrb_state , object : * <span class="kw-2">mut </span>RBasic) -&gt; mrb_bool ; } <span class="kw">pub type </span>mrb_code = u8 ; <span class="kw">pub type </span>mrb_aspec = u32 ; <span class="kw">pub type </span>mrb_allocf = :: std :: option :: <span class="prelude-ty">Option </span>&lt; <span class="kw">unsafe extern </span><span class="string">"C" </span><span class="kw">fn </span>(mrb : * <span class="kw-2">mut </span>mrb_state , arg1 : * <span class="kw-2">mut </span>:: std :: os :: raw :: c_void , arg2 : usize , ud : * <span class="kw-2">mut </span>:: std :: os :: raw :: c_void) -&gt; * <span class="kw-2">mut </span>:: std :: os :: raw :: c_void &gt; ; # [repr (C)] # [derive (Copy , Clone)] <span class="kw">pub struct </span>mrb_callinfo { <span class="kw">pub </span>_bitfield_align_1 : [u8 ; <span class="number">0</span>] , <span class="kw">pub </span>_bitfield_1 : __BindgenBitfieldUnit &lt; [u8 ; <span class="number">1usize</span>] &gt; , <span class="kw">pub </span>cci : u8 , <span class="kw">pub </span>mid : mrb_sym , <span class="kw">pub </span>proc_ : * <span class="kw">const </span>RProc , <span class="kw">pub </span>blk : * <span class="kw-2">mut </span>RProc , <span class="kw">pub </span>stack : * <span class="kw-2">mut </span>mrb_value , <span class="kw">pub </span>pc : * <span class="kw">const </span>mrb_code , <span class="kw">pub </span>u : mrb_callinfo__bindgen_ty_1 , } # [repr (C)] # [derive (Copy , Clone)] <span class="kw">pub union </span>mrb_callinfo__bindgen_ty_1 { <span class="kw">pub </span>env : * <span class="kw-2">mut </span>REnv , <span class="kw">pub </span>target_class : * <span class="kw-2">mut </span>RClass , } # [test] <span class="kw">fn </span>bindgen_test_layout_mrb_callinfo__bindgen_ty_1 () { <span class="kw">const </span>UNINIT : :: std :: mem :: MaybeUninit &lt; mrb_callinfo__bindgen_ty_1 &gt; = :: std :: mem :: MaybeUninit :: uninit () ; <span class="kw">let </span>ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: &lt; mrb_callinfo__bindgen_ty_1 &gt; () , <span class="number">8usize </span>, concat ! (<span class="string">"Size of: " </span>, stringify ! (mrb_callinfo__bindgen_ty_1))) ; assert_eq ! (:: std :: mem :: align_of :: &lt; mrb_callinfo__bindgen_ty_1 &gt; () , <span class="number">8usize </span>, concat ! (<span class="string">"Alignment of " </span>, stringify ! (mrb_callinfo__bindgen_ty_1))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . env) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">0usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (mrb_callinfo__bindgen_ty_1) , <span class="string">"::" </span>, stringify ! (env))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . target_class) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">0usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (mrb_callinfo__bindgen_ty_1) , <span class="string">"::" </span>, stringify ! (target_class))) ; } # [test] <span class="kw">fn </span>bindgen_test_layout_mrb_callinfo () { <span class="kw">const </span>UNINIT : :: std :: mem :: MaybeUninit &lt; mrb_callinfo &gt; = :: std :: mem :: MaybeUninit :: uninit () ; <span class="kw">let </span>ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: &lt; mrb_callinfo &gt; () , <span class="number">48usize </span>, concat ! (<span class="string">"Size of: " </span>, stringify ! (mrb_callinfo))) ; assert_eq ! (:: std :: mem :: align_of :: &lt; mrb_callinfo &gt; () , <span class="number">8usize </span>, concat ! (<span class="string">"Alignment of " </span>, stringify ! (mrb_callinfo))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . cci) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">1usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (mrb_callinfo) , <span class="string">"::" </span>, stringify ! (cci))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . mid) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">4usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (mrb_callinfo) , <span class="string">"::" </span>, stringify ! (mid))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . proc_) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">8usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (mrb_callinfo) , <span class="string">"::" </span>, stringify ! (proc_))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . blk) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">16usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (mrb_callinfo) , <span class="string">"::" </span>, stringify ! (blk))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . stack) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">24usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (mrb_callinfo) , <span class="string">"::" </span>, stringify ! (stack))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . pc) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">32usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (mrb_callinfo) , <span class="string">"::" </span>, stringify ! (pc))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . u) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">40usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (mrb_callinfo) , <span class="string">"::" </span>, stringify ! (u))) ; } <span class="kw">impl </span>mrb_callinfo { # [inline] <span class="kw">pub fn </span>n (&amp; <span class="self">self</span>) -&gt; u8 { <span class="kw">unsafe </span>{ :: std :: mem :: transmute (<span class="self">self </span>. _bitfield_1 . get (<span class="number">0usize </span>, <span class="number">4u8</span>) <span class="kw">as </span>u8) } } # [inline] <span class="kw">pub fn </span>set_n (&amp; <span class="kw-2">mut </span><span class="self">self </span>, val : u8) { <span class="kw">unsafe </span>{ <span class="kw">let </span>val : u8 = :: std :: mem :: transmute (val) ; <span class="self">self </span>. _bitfield_1 . set (<span class="number">0usize </span>, <span class="number">4u8 </span>, val <span class="kw">as </span>u64) } } # [inline] <span class="kw">pub fn </span>nk (&amp; <span class="self">self</span>) -&gt; u8 { <span class="kw">unsafe </span>{ :: std :: mem :: transmute (<span class="self">self </span>. _bitfield_1 . get (<span class="number">4usize </span>, <span class="number">4u8</span>) <span class="kw">as </span>u8) } } # [inline] <span class="kw">pub fn </span>set_nk (&amp; <span class="kw-2">mut </span><span class="self">self </span>, val : u8) { <span class="kw">unsafe </span>{ <span class="kw">let </span>val : u8 = :: std :: mem :: transmute (val) ; <span class="self">self </span>. _bitfield_1 . set (<span class="number">4usize </span>, <span class="number">4u8 </span>, val <span class="kw">as </span>u64) } } # [inline] <span class="kw">pub fn </span>new_bitfield_1 (n : u8 , nk : u8) -&gt; __BindgenBitfieldUnit &lt; [u8 ; <span class="number">1usize</span>] &gt; { <span class="kw">let </span><span class="kw-2">mut </span>__bindgen_bitfield_unit : __BindgenBitfieldUnit &lt; [u8 ; <span class="number">1usize</span>] &gt; = Default :: default () ; __bindgen_bitfield_unit . set (<span class="number">0usize </span>, <span class="number">4u8 </span>, { <span class="kw">let </span>n : u8 = <span class="kw">unsafe </span>{ :: std :: mem :: transmute (n) } ; n <span class="kw">as </span>u64 }) ; __bindgen_bitfield_unit . set (<span class="number">4usize </span>, <span class="number">4u8 </span>, { <span class="kw">let </span>nk : u8 = <span class="kw">unsafe </span>{ :: std :: mem :: transmute (nk) } ; nk <span class="kw">as </span>u64 }) ; __bindgen_bitfield_unit } } # [repr (u32)] # [derive (Debug , Copy , Clone , Hash , PartialEq , Eq)] <span class="kw">pub enum </span>mrb_fiber_state { MRB_FIBER_CREATED = <span class="number">0 </span>, MRB_FIBER_RUNNING = <span class="number">1 </span>, MRB_FIBER_RESUMED = <span class="number">2 </span>, MRB_FIBER_SUSPENDED = <span class="number">3 </span>, MRB_FIBER_TRANSFERRED = <span class="number">4 </span>, MRB_FIBER_TERMINATED = <span class="number">5 </span>, } # [repr (C)] # [derive (Debug , Copy , Clone)] <span class="kw">pub struct </span>mrb_context { <span class="kw">pub </span>prev : * <span class="kw-2">mut </span>mrb_context , <span class="kw">pub </span>stbase : * <span class="kw-2">mut </span>mrb_value , <span class="kw">pub </span>stend : * <span class="kw-2">mut </span>mrb_value , <span class="kw">pub </span>ci : * <span class="kw-2">mut </span>mrb_callinfo , <span class="kw">pub </span>cibase : * <span class="kw-2">mut </span>mrb_callinfo , <span class="kw">pub </span>ciend : * <span class="kw-2">mut </span>mrb_callinfo , <span class="kw">pub </span>_bitfield_align_1 : [u8 ; <span class="number">0</span>] , <span class="kw">pub </span>_bitfield_1 : __BindgenBitfieldUnit &lt; [u8 ; <span class="number">1usize</span>] &gt; , <span class="kw">pub </span>fib : * <span class="kw-2">mut </span>RFiber , } # [test] <span class="kw">fn </span>bindgen_test_layout_mrb_context () { <span class="kw">const </span>UNINIT : :: std :: mem :: MaybeUninit &lt; mrb_context &gt; = :: std :: mem :: MaybeUninit :: uninit () ; <span class="kw">let </span>ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: &lt; mrb_context &gt; () , <span class="number">64usize </span>, concat ! (<span class="string">"Size of: " </span>, stringify ! (mrb_context))) ; assert_eq ! (:: std :: mem :: align_of :: &lt; mrb_context &gt; () , <span class="number">8usize </span>, concat ! (<span class="string">"Alignment of " </span>, stringify ! (mrb_context))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . prev) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">0usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (mrb_context) , <span class="string">"::" </span>, stringify ! (prev))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . stbase) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">8usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (mrb_context) , <span class="string">"::" </span>, stringify ! (stbase))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . stend) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">16usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (mrb_context) , <span class="string">"::" </span>, stringify ! (stend))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . ci) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">24usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (mrb_context) , <span class="string">"::" </span>, stringify ! (ci))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . cibase) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">32usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (mrb_context) , <span class="string">"::" </span>, stringify ! (cibase))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . ciend) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">40usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (mrb_context) , <span class="string">"::" </span>, stringify ! (ciend))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . fib) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">56usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (mrb_context) , <span class="string">"::" </span>, stringify ! (fib))) ; } <span class="kw">impl </span>mrb_context { # [inline] <span class="kw">pub fn </span>status (&amp; <span class="self">self</span>) -&gt; mrb_fiber_state { <span class="kw">unsafe </span>{ :: std :: mem :: transmute (<span class="self">self </span>. _bitfield_1 . get (<span class="number">0usize </span>, <span class="number">4u8</span>) <span class="kw">as </span>u32) } } # [inline] <span class="kw">pub fn </span>set_status (&amp; <span class="kw-2">mut </span><span class="self">self </span>, val : mrb_fiber_state) { <span class="kw">unsafe </span>{ <span class="kw">let </span>val : u32 = :: std :: mem :: transmute (val) ; <span class="self">self </span>. _bitfield_1 . set (<span class="number">0usize </span>, <span class="number">4u8 </span>, val <span class="kw">as </span>u64) } } # [inline] <span class="kw">pub fn </span>vmexec (&amp; <span class="self">self</span>) -&gt; mrb_bool { <span class="kw">unsafe </span>{ :: std :: mem :: transmute (<span class="self">self </span>. _bitfield_1 . get (<span class="number">4usize </span>, <span class="number">1u8</span>) <span class="kw">as </span>u8) } } # [inline] <span class="kw">pub fn </span>set_vmexec (&amp; <span class="kw-2">mut </span><span class="self">self </span>, val : mrb_bool) { <span class="kw">unsafe </span>{ <span class="kw">let </span>val : u8 = :: std :: mem :: transmute (val) ; <span class="self">self </span>. _bitfield_1 . set (<span class="number">4usize </span>, <span class="number">1u8 </span>, val <span class="kw">as </span>u64) } } # [inline] <span class="kw">pub fn </span>new_bitfield_1 (status : mrb_fiber_state , vmexec : mrb_bool) -&gt; __BindgenBitfieldUnit &lt; [u8 ; <span class="number">1usize</span>] &gt; { <span class="kw">let </span><span class="kw-2">mut </span>__bindgen_bitfield_unit : __BindgenBitfieldUnit &lt; [u8 ; <span class="number">1usize</span>] &gt; = Default :: default () ; __bindgen_bitfield_unit . set (<span class="number">0usize </span>, <span class="number">4u8 </span>, { <span class="kw">let </span>status : u32 = <span class="kw">unsafe </span>{ :: std :: mem :: transmute (status) } ; status <span class="kw">as </span>u64 }) ; __bindgen_bitfield_unit . set (<span class="number">4usize </span>, <span class="number">1u8 </span>, { <span class="kw">let </span>vmexec : u8 = <span class="kw">unsafe </span>{ :: std :: mem :: transmute (vmexec) } ; vmexec <span class="kw">as </span>u64 }) ; __bindgen_bitfield_unit } } <span class="kw">pub type </span>mrb_func_t = :: std :: option :: <span class="prelude-ty">Option </span>&lt; <span class="kw">unsafe extern </span><span class="string">"C" </span><span class="kw">fn </span>(mrb : * <span class="kw-2">mut </span>mrb_state , self_ : mrb_value) -&gt; mrb_value &gt; ; <span class="kw">pub type </span>mrb_method_t = usize ; # [repr (C)] # [derive (Debug , Copy , Clone)] <span class="kw">pub struct </span>mrb_cache_entry { <span class="kw">pub </span>c : * <span class="kw-2">mut </span>RClass , <span class="kw">pub </span>c0 : * <span class="kw-2">mut </span>RClass , <span class="kw">pub </span>mid : mrb_sym , <span class="kw">pub </span>m : mrb_method_t , } # [test] <span class="kw">fn </span>bindgen_test_layout_mrb_cache_entry () { <span class="kw">const </span>UNINIT : :: std :: mem :: MaybeUninit &lt; mrb_cache_entry &gt; = :: std :: mem :: MaybeUninit :: uninit () ; <span class="kw">let </span>ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: &lt; mrb_cache_entry &gt; () , <span class="number">32usize </span>, concat ! (<span class="string">"Size of: " </span>, stringify ! (mrb_cache_entry))) ; assert_eq ! (:: std :: mem :: align_of :: &lt; mrb_cache_entry &gt; () , <span class="number">8usize </span>, concat ! (<span class="string">"Alignment of " </span>, stringify ! (mrb_cache_entry))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . c) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">0usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (mrb_cache_entry) , <span class="string">"::" </span>, stringify ! (c))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . c0) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">8usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (mrb_cache_entry) , <span class="string">"::" </span>, stringify ! (c0))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . mid) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">16usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (mrb_cache_entry) , <span class="string">"::" </span>, stringify ! (mid))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . m) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">24usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (mrb_cache_entry) , <span class="string">"::" </span>, stringify ! (m))) ; } <span class="kw">pub type </span>mrb_atexit_func = :: std :: option :: <span class="prelude-ty">Option </span>&lt; <span class="kw">unsafe extern </span><span class="string">"C" </span><span class="kw">fn </span>(arg1 : * <span class="kw-2">mut </span>mrb_state) &gt; ; # [repr (C)] # [derive (Debug , Copy , Clone)] <span class="kw">pub struct </span>mrb_state { <span class="kw">pub </span>jmp : * <span class="kw-2">mut </span>mrb_jmpbuf , <span class="kw">pub </span>allocf : mrb_allocf , <span class="kw">pub </span>allocf_ud : * <span class="kw-2">mut </span>:: std :: os :: raw :: c_void , <span class="kw">pub </span>c : * <span class="kw-2">mut </span>mrb_context , <span class="kw">pub </span>root_c : * <span class="kw-2">mut </span>mrb_context , <span class="kw">pub </span>globals : * <span class="kw-2">mut </span>iv_tbl , <span class="kw">pub </span>exc : * <span class="kw-2">mut </span>RObject , <span class="kw">pub </span>top_self : * <span class="kw-2">mut </span>RObject , <span class="kw">pub </span>object_class : * <span class="kw-2">mut </span>RClass , <span class="kw">pub </span>class_class : * <span class="kw-2">mut </span>RClass , <span class="kw">pub </span>module_class : * <span class="kw-2">mut </span>RClass , <span class="kw">pub </span>proc_class : * <span class="kw-2">mut </span>RClass , <span class="kw">pub </span>string_class : * <span class="kw-2">mut </span>RClass , <span class="kw">pub </span>array_class : * <span class="kw-2">mut </span>RClass , <span class="kw">pub </span>hash_class : * <span class="kw-2">mut </span>RClass , <span class="kw">pub </span>range_class : * <span class="kw-2">mut </span>RClass , <span class="kw">pub </span>float_class : * <span class="kw-2">mut </span>RClass , <span class="kw">pub </span>integer_class : * <span class="kw-2">mut </span>RClass , <span class="kw">pub </span>true_class : * <span class="kw-2">mut </span>RClass , <span class="kw">pub </span>false_class : * <span class="kw-2">mut </span>RClass , <span class="kw">pub </span>nil_class : * <span class="kw-2">mut </span>RClass , <span class="kw">pub </span>symbol_class : * <span class="kw-2">mut </span>RClass , <span class="kw">pub </span>kernel_module : * <span class="kw-2">mut </span>RClass , <span class="kw">pub </span>gc : mrb_gc , <span class="kw">pub </span>cache : [mrb_cache_entry ; <span class="number">256usize</span>] , <span class="kw">pub </span>symidx : mrb_sym , <span class="kw">pub </span>symtbl : * <span class="kw-2">mut </span>* <span class="kw">const </span>:: std :: os :: raw :: c_char , <span class="kw">pub </span>symlink : * <span class="kw-2">mut </span>u8 , <span class="kw">pub </span>symflags : * <span class="kw-2">mut </span>u8 , <span class="kw">pub </span>symhash : [mrb_sym ; <span class="number">256usize</span>] , <span class="kw">pub </span>symcapa : usize , <span class="kw">pub </span>symbuf : [:: std :: os :: raw :: c_char ; <span class="number">8usize</span>] , <span class="kw">pub </span>eException_class : * <span class="kw-2">mut </span>RClass , <span class="kw">pub </span>eStandardError_class : * <span class="kw-2">mut </span>RClass , <span class="kw">pub </span>nomem_err : * <span class="kw-2">mut </span>RObject , <span class="kw">pub </span>stack_err : * <span class="kw-2">mut </span>RObject , <span class="kw">pub </span>ud : * <span class="kw-2">mut </span>:: std :: os :: raw :: c_void , <span class="kw">pub </span>atexit_stack : * <span class="kw-2">mut </span>mrb_atexit_func , <span class="kw">pub </span>atexit_stack_len : u16 , } # [test] <span class="kw">fn </span>bindgen_test_layout_mrb_state () { <span class="kw">const </span>UNINIT : :: std :: mem :: MaybeUninit &lt; mrb_state &gt; = :: std :: mem :: MaybeUninit :: uninit () ; <span class="kw">let </span>ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: &lt; mrb_state &gt; () , <span class="number">9616usize </span>, concat ! (<span class="string">"Size of: " </span>, stringify ! (mrb_state))) ; assert_eq ! (:: std :: mem :: align_of :: &lt; mrb_state &gt; () , <span class="number">8usize </span>, concat ! (<span class="string">"Alignment of " </span>, stringify ! (mrb_state))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . jmp) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">0usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (mrb_state) , <span class="string">"::" </span>, stringify ! (jmp))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . allocf) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">8usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (mrb_state) , <span class="string">"::" </span>, stringify ! (allocf))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . allocf_ud) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">16usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (mrb_state) , <span class="string">"::" </span>, stringify ! (allocf_ud))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . c) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">24usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (mrb_state) , <span class="string">"::" </span>, stringify ! (c))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . root_c) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">32usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (mrb_state) , <span class="string">"::" </span>, stringify ! (root_c))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . globals) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">40usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (mrb_state) , <span class="string">"::" </span>, stringify ! (globals))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . exc) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">48usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (mrb_state) , <span class="string">"::" </span>, stringify ! (exc))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . top_self) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">56usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (mrb_state) , <span class="string">"::" </span>, stringify ! (top_self))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . object_class) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">64usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (mrb_state) , <span class="string">"::" </span>, stringify ! (object_class))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . class_class) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">72usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (mrb_state) , <span class="string">"::" </span>, stringify ! (class_class))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . module_class) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">80usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (mrb_state) , <span class="string">"::" </span>, stringify ! (module_class))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . proc_class) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">88usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (mrb_state) , <span class="string">"::" </span>, stringify ! (proc_class))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . string_class) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">96usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (mrb_state) , <span class="string">"::" </span>, stringify ! (string_class))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . array_class) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">104usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (mrb_state) , <span class="string">"::" </span>, stringify ! (array_class))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . hash_class) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">112usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (mrb_state) , <span class="string">"::" </span>, stringify ! (hash_class))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . range_class) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">120usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (mrb_state) , <span class="string">"::" </span>, stringify ! (range_class))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . float_class) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">128usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (mrb_state) , <span class="string">"::" </span>, stringify ! (float_class))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . integer_class) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">136usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (mrb_state) , <span class="string">"::" </span>, stringify ! (integer_class))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . true_class) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">144usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (mrb_state) , <span class="string">"::" </span>, stringify ! (true_class))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . false_class) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">152usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (mrb_state) , <span class="string">"::" </span>, stringify ! (false_class))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . nil_class) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">160usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (mrb_state) , <span class="string">"::" </span>, stringify ! (nil_class))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . symbol_class) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">168usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (mrb_state) , <span class="string">"::" </span>, stringify ! (symbol_class))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . kernel_module) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">176usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (mrb_state) , <span class="string">"::" </span>, stringify ! (kernel_module))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . gc) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">184usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (mrb_state) , <span class="string">"::" </span>, stringify ! (gc))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . cache) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">296usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (mrb_state) , <span class="string">"::" </span>, stringify ! (cache))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . symidx) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">8488usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (mrb_state) , <span class="string">"::" </span>, stringify ! (symidx))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . symtbl) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">8496usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (mrb_state) , <span class="string">"::" </span>, stringify ! (symtbl))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . symlink) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">8504usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (mrb_state) , <span class="string">"::" </span>, stringify ! (symlink))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . symflags) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">8512usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (mrb_state) , <span class="string">"::" </span>, stringify ! (symflags))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . symhash) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">8520usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (mrb_state) , <span class="string">"::" </span>, stringify ! (symhash))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . symcapa) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">9544usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (mrb_state) , <span class="string">"::" </span>, stringify ! (symcapa))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . symbuf) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">9552usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (mrb_state) , <span class="string">"::" </span>, stringify ! (symbuf))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . eException_class) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">9560usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (mrb_state) , <span class="string">"::" </span>, stringify ! (eException_class))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . eStandardError_class) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">9568usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (mrb_state) , <span class="string">"::" </span>, stringify ! (eStandardError_class))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . nomem_err) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">9576usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (mrb_state) , <span class="string">"::" </span>, stringify ! (nomem_err))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . stack_err) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">9584usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (mrb_state) , <span class="string">"::" </span>, stringify ! (stack_err))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . ud) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">9592usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (mrb_state) , <span class="string">"::" </span>, stringify ! (ud))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . atexit_stack) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">9600usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (mrb_state) , <span class="string">"::" </span>, stringify ! (atexit_stack))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . atexit_stack_len) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">9608usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (mrb_state) , <span class="string">"::" </span>, stringify ! (atexit_stack_len))) ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_define_class (mrb : * <span class="kw-2">mut </span>mrb_state , name : * <span class="kw">const </span>:: std :: os :: raw :: c_char , super_ : * <span class="kw-2">mut </span>RClass) -&gt; * <span class="kw-2">mut </span>RClass ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_define_class_id (mrb : * <span class="kw-2">mut </span>mrb_state , name : mrb_sym , super_ : * <span class="kw-2">mut </span>RClass) -&gt; * <span class="kw-2">mut </span>RClass ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_define_module (mrb : * <span class="kw-2">mut </span>mrb_state , name : * <span class="kw">const </span>:: std :: os :: raw :: c_char) -&gt; * <span class="kw-2">mut </span>RClass ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_define_module_id (mrb : * <span class="kw-2">mut </span>mrb_state , name : mrb_sym) -&gt; * <span class="kw-2">mut </span>RClass ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_singleton_class (mrb : * <span class="kw-2">mut </span>mrb_state , val : mrb_value) -&gt; mrb_value ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_singleton_class_ptr (mrb : * <span class="kw-2">mut </span>mrb_state , val : mrb_value) -&gt; * <span class="kw-2">mut </span>RClass ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_include_module (mrb : * <span class="kw-2">mut </span>mrb_state , cla : * <span class="kw-2">mut </span>RClass , included : * <span class="kw-2">mut </span>RClass) ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_prepend_module (mrb : * <span class="kw-2">mut </span>mrb_state , cla : * <span class="kw-2">mut </span>RClass , prepended : * <span class="kw-2">mut </span>RClass) ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_define_method (mrb : * <span class="kw-2">mut </span>mrb_state , cla : * <span class="kw-2">mut </span>RClass , name : * <span class="kw">const </span>:: std :: os :: raw :: c_char , func : mrb_func_t , aspec : mrb_aspec) ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_define_method_id (mrb : * <span class="kw-2">mut </span>mrb_state , c : * <span class="kw-2">mut </span>RClass , mid : mrb_sym , func : mrb_func_t , aspec : mrb_aspec) ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_define_class_method (mrb : * <span class="kw-2">mut </span>mrb_state , cla : * <span class="kw-2">mut </span>RClass , name : * <span class="kw">const </span>:: std :: os :: raw :: c_char , fun : mrb_func_t , aspec : mrb_aspec) ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_define_class_method_id (mrb : * <span class="kw-2">mut </span>mrb_state , cla : * <span class="kw-2">mut </span>RClass , name : mrb_sym , fun : mrb_func_t , aspec : mrb_aspec) ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_define_singleton_method (mrb : * <span class="kw-2">mut </span>mrb_state , cla : * <span class="kw-2">mut </span>RObject , name : * <span class="kw">const </span>:: std :: os :: raw :: c_char , fun : mrb_func_t , aspec : mrb_aspec) ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_define_singleton_method_id (mrb : * <span class="kw-2">mut </span>mrb_state , cla : * <span class="kw-2">mut </span>RObject , name : mrb_sym , fun : mrb_func_t , aspec : mrb_aspec) ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_define_module_function (mrb : * <span class="kw-2">mut </span>mrb_state , cla : * <span class="kw-2">mut </span>RClass , name : * <span class="kw">const </span>:: std :: os :: raw :: c_char , fun : mrb_func_t , aspec : mrb_aspec) ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_define_module_function_id (mrb : * <span class="kw-2">mut </span>mrb_state , cla : * <span class="kw-2">mut </span>RClass , name : mrb_sym , fun : mrb_func_t , aspec : mrb_aspec) ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_define_const (mrb : * <span class="kw-2">mut </span>mrb_state , cla : * <span class="kw-2">mut </span>RClass , name : * <span class="kw">const </span>:: std :: os :: raw :: c_char , val : mrb_value) ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_define_const_id (mrb : * <span class="kw-2">mut </span>mrb_state , cla : * <span class="kw-2">mut </span>RClass , name : mrb_sym , val : mrb_value) ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_undef_method (mrb : * <span class="kw-2">mut </span>mrb_state , cla : * <span class="kw-2">mut </span>RClass , name : * <span class="kw">const </span>:: std :: os :: raw :: c_char) ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_undef_method_id (arg1 : * <span class="kw-2">mut </span>mrb_state , arg2 : * <span class="kw-2">mut </span>RClass , arg3 : mrb_sym) ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_undef_class_method (mrb : * <span class="kw-2">mut </span>mrb_state , cls : * <span class="kw-2">mut </span>RClass , name : * <span class="kw">const </span>:: std :: os :: raw :: c_char) ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_undef_class_method_id (mrb : * <span class="kw-2">mut </span>mrb_state , cls : * <span class="kw-2">mut </span>RClass , name : mrb_sym) ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_obj_new (mrb : * <span class="kw-2">mut </span>mrb_state , c : * <span class="kw-2">mut </span>RClass , argc : mrb_int , argv : * <span class="kw">const </span>mrb_value) -&gt; mrb_value ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_class_new (mrb : * <span class="kw-2">mut </span>mrb_state , super_ : * <span class="kw-2">mut </span>RClass) -&gt; * <span class="kw-2">mut </span>RClass ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_module_new (mrb : * <span class="kw-2">mut </span>mrb_state) -&gt; * <span class="kw-2">mut </span>RClass ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_class_defined (mrb : * <span class="kw-2">mut </span>mrb_state , name : * <span class="kw">const </span>:: std :: os :: raw :: c_char) -&gt; mrb_bool ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_class_defined_id (mrb : * <span class="kw-2">mut </span>mrb_state , name : mrb_sym) -&gt; mrb_bool ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_class_get (mrb : * <span class="kw-2">mut </span>mrb_state , name : * <span class="kw">const </span>:: std :: os :: raw :: c_char) -&gt; * <span class="kw-2">mut </span>RClass ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_class_get_id (mrb : * <span class="kw-2">mut </span>mrb_state , name : mrb_sym) -&gt; * <span class="kw-2">mut </span>RClass ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_exc_get_id (mrb : * <span class="kw-2">mut </span>mrb_state , name : mrb_sym) -&gt; * <span class="kw-2">mut </span>RClass ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_class_defined_under (mrb : * <span class="kw-2">mut </span>mrb_state , outer : * <span class="kw-2">mut </span>RClass , name : * <span class="kw">const </span>:: std :: os :: raw :: c_char) -&gt; mrb_bool ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_class_defined_under_id (mrb : * <span class="kw-2">mut </span>mrb_state , outer : * <span class="kw-2">mut </span>RClass , name : mrb_sym) -&gt; mrb_bool ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_class_get_under (mrb : * <span class="kw-2">mut </span>mrb_state , outer : * <span class="kw-2">mut </span>RClass , name : * <span class="kw">const </span>:: std :: os :: raw :: c_char) -&gt; * <span class="kw-2">mut </span>RClass ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_class_get_under_id (mrb : * <span class="kw-2">mut </span>mrb_state , outer : * <span class="kw-2">mut </span>RClass , name : mrb_sym) -&gt; * <span class="kw-2">mut </span>RClass ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_module_get (mrb : * <span class="kw-2">mut </span>mrb_state , name : * <span class="kw">const </span>:: std :: os :: raw :: c_char) -&gt; * <span class="kw-2">mut </span>RClass ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_module_get_id (mrb : * <span class="kw-2">mut </span>mrb_state , name : mrb_sym) -&gt; * <span class="kw-2">mut </span>RClass ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_module_get_under (mrb : * <span class="kw-2">mut </span>mrb_state , outer : * <span class="kw-2">mut </span>RClass , name : * <span class="kw">const </span>:: std :: os :: raw :: c_char) -&gt; * <span class="kw-2">mut </span>RClass ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_module_get_under_id (mrb : * <span class="kw-2">mut </span>mrb_state , outer : * <span class="kw-2">mut </span>RClass , name : mrb_sym) -&gt; * <span class="kw-2">mut </span>RClass ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_notimplement (arg1 : * <span class="kw-2">mut </span>mrb_state) ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_notimplement_m (arg1 : * <span class="kw-2">mut </span>mrb_state , arg2 : mrb_value) -&gt; mrb_value ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_obj_dup (mrb : * <span class="kw-2">mut </span>mrb_state , obj : mrb_value) -&gt; mrb_value ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_obj_respond_to (mrb : * <span class="kw-2">mut </span>mrb_state , c : * <span class="kw-2">mut </span>RClass , mid : mrb_sym) -&gt; mrb_bool ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_define_class_under (mrb : * <span class="kw-2">mut </span>mrb_state , outer : * <span class="kw-2">mut </span>RClass , name : * <span class="kw">const </span>:: std :: os :: raw :: c_char , super_ : * <span class="kw-2">mut </span>RClass) -&gt; * <span class="kw-2">mut </span>RClass ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_define_class_under_id (mrb : * <span class="kw-2">mut </span>mrb_state , outer : * <span class="kw-2">mut </span>RClass , name : mrb_sym , super_ : * <span class="kw-2">mut </span>RClass) -&gt; * <span class="kw-2">mut </span>RClass ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_define_module_under (mrb : * <span class="kw-2">mut </span>mrb_state , outer : * <span class="kw-2">mut </span>RClass , name : * <span class="kw">const </span>:: std :: os :: raw :: c_char) -&gt; * <span class="kw-2">mut </span>RClass ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_define_module_under_id (mrb : * <span class="kw-2">mut </span>mrb_state , outer : * <span class="kw-2">mut </span>RClass , name : mrb_sym) -&gt; * <span class="kw-2">mut </span>RClass ; } <span class="kw">pub type </span>mrb_args_format = * <span class="kw">const </span>:: std :: os :: raw :: c_char ; # [repr (C)] # [derive (Debug , Copy , Clone)] <span class="kw">pub struct </span>mrb_kwargs { <span class="kw">pub </span>num : mrb_int , <span class="kw">pub </span>required : mrb_int , <span class="kw">pub </span>table : * <span class="kw">const </span>mrb_sym , <span class="kw">pub </span>values : * <span class="kw-2">mut </span>mrb_value , <span class="kw">pub </span>rest : * <span class="kw-2">mut </span>mrb_value , } # [test] <span class="kw">fn </span>bindgen_test_layout_mrb_kwargs () { <span class="kw">const </span>UNINIT : :: std :: mem :: MaybeUninit &lt; mrb_kwargs &gt; = :: std :: mem :: MaybeUninit :: uninit () ; <span class="kw">let </span>ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: &lt; mrb_kwargs &gt; () , <span class="number">40usize </span>, concat ! (<span class="string">"Size of: " </span>, stringify ! (mrb_kwargs))) ; assert_eq ! (:: std :: mem :: align_of :: &lt; mrb_kwargs &gt; () , <span class="number">8usize </span>, concat ! (<span class="string">"Alignment of " </span>, stringify ! (mrb_kwargs))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . num) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">0usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (mrb_kwargs) , <span class="string">"::" </span>, stringify ! (num))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . required) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">8usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (mrb_kwargs) , <span class="string">"::" </span>, stringify ! (required))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . table) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">16usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (mrb_kwargs) , <span class="string">"::" </span>, stringify ! (table))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . values) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">24usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (mrb_kwargs) , <span class="string">"::" </span>, stringify ! (values))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . rest) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">32usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (mrb_kwargs) , <span class="string">"::" </span>, stringify ! (rest))) ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_get_args (mrb : * <span class="kw-2">mut </span>mrb_state , format : mrb_args_format , ...) -&gt; mrb_int ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_get_args_a (mrb : * <span class="kw-2">mut </span>mrb_state , format : mrb_args_format , ptr : * <span class="kw-2">mut </span>* <span class="kw-2">mut </span>:: std :: os :: raw :: c_void) -&gt; mrb_int ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_get_argc (mrb : * <span class="kw-2">mut </span>mrb_state) -&gt; mrb_int ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_get_argv (mrb : * <span class="kw-2">mut </span>mrb_state) -&gt; * <span class="kw">const </span>mrb_value ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_get_arg1 (mrb : * <span class="kw-2">mut </span>mrb_state) -&gt; mrb_value ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_block_given_p (mrb : * <span class="kw-2">mut </span>mrb_state) -&gt; mrb_bool ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_funcall (mrb : * <span class="kw-2">mut </span>mrb_state , val : mrb_value , name : * <span class="kw">const </span>:: std :: os :: raw :: c_char , argc : mrb_int , ...) -&gt; mrb_value ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_funcall_id (mrb : * <span class="kw-2">mut </span>mrb_state , val : mrb_value , mid : mrb_sym , argc : mrb_int , ...) -&gt; mrb_value ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_funcall_argv (mrb : * <span class="kw-2">mut </span>mrb_state , val : mrb_value , name : mrb_sym , argc : mrb_int , argv : * <span class="kw">const </span>mrb_value) -&gt; mrb_value ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_funcall_with_block (mrb : * <span class="kw-2">mut </span>mrb_state , val : mrb_value , name : mrb_sym , argc : mrb_int , argv : * <span class="kw">const </span>mrb_value , block : mrb_value) -&gt; mrb_value ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_intern_cstr (mrb : * <span class="kw-2">mut </span>mrb_state , str_ : * <span class="kw">const </span>:: std :: os :: raw :: c_char) -&gt; mrb_sym ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_intern (arg1 : * <span class="kw-2">mut </span>mrb_state , arg2 : * <span class="kw">const </span>:: std :: os :: raw :: c_char , arg3 : usize) -&gt; mrb_sym ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_intern_static (arg1 : * <span class="kw-2">mut </span>mrb_state , arg2 : * <span class="kw">const </span>:: std :: os :: raw :: c_char , arg3 : usize) -&gt; mrb_sym ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_intern_str (arg1 : * <span class="kw-2">mut </span>mrb_state , arg2 : mrb_value) -&gt; mrb_sym ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_intern_check_cstr (arg1 : * <span class="kw-2">mut </span>mrb_state , arg2 : * <span class="kw">const </span>:: std :: os :: raw :: c_char) -&gt; mrb_sym ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_intern_check (arg1 : * <span class="kw-2">mut </span>mrb_state , arg2 : * <span class="kw">const </span>:: std :: os :: raw :: c_char , arg3 : usize) -&gt; mrb_sym ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_intern_check_str (arg1 : * <span class="kw-2">mut </span>mrb_state , arg2 : mrb_value) -&gt; mrb_sym ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_check_intern_cstr (arg1 : * <span class="kw-2">mut </span>mrb_state , arg2 : * <span class="kw">const </span>:: std :: os :: raw :: c_char) -&gt; mrb_value ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_check_intern (arg1 : * <span class="kw-2">mut </span>mrb_state , arg2 : * <span class="kw">const </span>:: std :: os :: raw :: c_char , arg3 : usize) -&gt; mrb_value ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_check_intern_str (arg1 : * <span class="kw-2">mut </span>mrb_state , arg2 : mrb_value) -&gt; mrb_value ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_sym_name (arg1 : * <span class="kw-2">mut </span>mrb_state , arg2 : mrb_sym) -&gt; * <span class="kw">const </span>:: std :: os :: raw :: c_char ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_sym_name_len (arg1 : * <span class="kw-2">mut </span>mrb_state , arg2 : mrb_sym , arg3 : * <span class="kw-2">mut </span>mrb_int) -&gt; * <span class="kw">const </span>:: std :: os :: raw :: c_char ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_sym_dump (arg1 : * <span class="kw-2">mut </span>mrb_state , arg2 : mrb_sym) -&gt; * <span class="kw">const </span>:: std :: os :: raw :: c_char ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_sym_str (arg1 : * <span class="kw-2">mut </span>mrb_state , arg2 : mrb_sym) -&gt; mrb_value ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_malloc (arg1 : * <span class="kw-2">mut </span>mrb_state , arg2 : usize) -&gt; * <span class="kw-2">mut </span>:: std :: os :: raw :: c_void ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_calloc (arg1 : * <span class="kw-2">mut </span>mrb_state , arg2 : usize , arg3 : usize) -&gt; * <span class="kw-2">mut </span>:: std :: os :: raw :: c_void ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_realloc (arg1 : * <span class="kw-2">mut </span>mrb_state , arg2 : * <span class="kw-2">mut </span>:: std :: os :: raw :: c_void , arg3 : usize) -&gt; * <span class="kw-2">mut </span>:: std :: os :: raw :: c_void ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_realloc_simple (arg1 : * <span class="kw-2">mut </span>mrb_state , arg2 : * <span class="kw-2">mut </span>:: std :: os :: raw :: c_void , arg3 : usize) -&gt; * <span class="kw-2">mut </span>:: std :: os :: raw :: c_void ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_malloc_simple (arg1 : * <span class="kw-2">mut </span>mrb_state , arg2 : usize) -&gt; * <span class="kw-2">mut </span>:: std :: os :: raw :: c_void ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_obj_alloc (arg1 : * <span class="kw-2">mut </span>mrb_state , arg2 : mrb_vtype , arg3 : * <span class="kw-2">mut </span>RClass) -&gt; * <span class="kw-2">mut </span>RBasic ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_free (arg1 : * <span class="kw-2">mut </span>mrb_state , arg2 : * <span class="kw-2">mut </span>:: std :: os :: raw :: c_void) ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_str_new (mrb : * <span class="kw-2">mut </span>mrb_state , p : * <span class="kw">const </span>:: std :: os :: raw :: c_char , len : mrb_int) -&gt; mrb_value ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_str_new_cstr (arg1 : * <span class="kw-2">mut </span>mrb_state , arg2 : * <span class="kw">const </span>:: std :: os :: raw :: c_char) -&gt; mrb_value ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_str_new_static (mrb : * <span class="kw-2">mut </span>mrb_state , p : * <span class="kw">const </span>:: std :: os :: raw :: c_char , len : mrb_int) -&gt; mrb_value ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_obj_freeze (arg1 : * <span class="kw-2">mut </span>mrb_state , arg2 : mrb_value) -&gt; mrb_value ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_open () -&gt; * <span class="kw-2">mut </span>mrb_state ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_open_allocf (f : mrb_allocf , ud : * <span class="kw-2">mut </span>:: std :: os :: raw :: c_void) -&gt; * <span class="kw-2">mut </span>mrb_state ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_open_core (f : mrb_allocf , ud : * <span class="kw-2">mut </span>:: std :: os :: raw :: c_void) -&gt; * <span class="kw-2">mut </span>mrb_state ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_close (mrb : * <span class="kw-2">mut </span>mrb_state) ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_default_allocf (arg1 : * <span class="kw-2">mut </span>mrb_state , arg2 : * <span class="kw-2">mut </span>:: std :: os :: raw :: c_void , arg3 : usize , arg4 : * <span class="kw-2">mut </span>:: std :: os :: raw :: c_void) -&gt; * <span class="kw-2">mut </span>:: std :: os :: raw :: c_void ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_top_self (mrb : * <span class="kw-2">mut </span>mrb_state) -&gt; mrb_value ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_top_run (mrb : * <span class="kw-2">mut </span>mrb_state , proc_ : * <span class="kw">const </span>RProc , self_ : mrb_value , stack_keep : mrb_int) -&gt; mrb_value ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_vm_run (mrb : * <span class="kw-2">mut </span>mrb_state , proc_ : * <span class="kw">const </span>RProc , self_ : mrb_value , stack_keep : mrb_int) -&gt; mrb_value ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_vm_exec (mrb : * <span class="kw-2">mut </span>mrb_state , proc_ : * <span class="kw">const </span>RProc , iseq : * <span class="kw">const </span>mrb_code) -&gt; mrb_value ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_p (arg1 : * <span class="kw-2">mut </span>mrb_state , arg2 : mrb_value) ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_obj_id (obj : mrb_value) -&gt; mrb_int ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_obj_to_sym (mrb : * <span class="kw-2">mut </span>mrb_state , name : mrb_value) -&gt; mrb_sym ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_obj_eq (mrb : * <span class="kw-2">mut </span>mrb_state , a : mrb_value , b : mrb_value) -&gt; mrb_bool ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_obj_equal (mrb : * <span class="kw-2">mut </span>mrb_state , a : mrb_value , b : mrb_value) -&gt; mrb_bool ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_equal (mrb : * <span class="kw-2">mut </span>mrb_state , obj1 : mrb_value , obj2 : mrb_value) -&gt; mrb_bool ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_ensure_float_type (mrb : * <span class="kw-2">mut </span>mrb_state , val : mrb_value) -&gt; mrb_value ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_inspect (mrb : * <span class="kw-2">mut </span>mrb_state , obj : mrb_value) -&gt; mrb_value ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_eql (mrb : * <span class="kw-2">mut </span>mrb_state , obj1 : mrb_value , obj2 : mrb_value) -&gt; mrb_bool ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_cmp (mrb : * <span class="kw-2">mut </span>mrb_state , obj1 : mrb_value , obj2 : mrb_value) -&gt; mrb_int ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_garbage_collect (arg1 : * <span class="kw-2">mut </span>mrb_state) ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_full_gc (arg1 : * <span class="kw-2">mut </span>mrb_state) ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_incremental_gc (arg1 : * <span class="kw-2">mut </span>mrb_state) ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_gc_mark (arg1 : * <span class="kw-2">mut </span>mrb_state , arg2 : * <span class="kw-2">mut </span>RBasic) ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_field_write_barrier (arg1 : * <span class="kw-2">mut </span>mrb_state , arg2 : * <span class="kw-2">mut </span>RBasic , arg3 : * <span class="kw-2">mut </span>RBasic) ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_write_barrier (arg1 : * <span class="kw-2">mut </span>mrb_state , arg2 : * <span class="kw-2">mut </span>RBasic) ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_type_convert (mrb : * <span class="kw-2">mut </span>mrb_state , val : mrb_value , type_ : mrb_vtype , method : mrb_sym) -&gt; mrb_value ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_type_convert_check (mrb : * <span class="kw-2">mut </span>mrb_state , val : mrb_value , type_ : mrb_vtype , method : mrb_sym) -&gt; mrb_value ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_any_to_s (mrb : * <span class="kw-2">mut </span>mrb_state , obj : mrb_value) -&gt; mrb_value ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_obj_classname (mrb : * <span class="kw-2">mut </span>mrb_state , obj : mrb_value) -&gt; * <span class="kw">const </span>:: std :: os :: raw :: c_char ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_obj_class (mrb : * <span class="kw-2">mut </span>mrb_state , obj : mrb_value) -&gt; * <span class="kw-2">mut </span>RClass ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_class_path (mrb : * <span class="kw-2">mut </span>mrb_state , c : * <span class="kw-2">mut </span>RClass) -&gt; mrb_value ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_obj_is_kind_of (mrb : * <span class="kw-2">mut </span>mrb_state , obj : mrb_value , c : * <span class="kw-2">mut </span>RClass) -&gt; mrb_bool ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_obj_inspect (mrb : * <span class="kw-2">mut </span>mrb_state , self_ : mrb_value) -&gt; mrb_value ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_obj_clone (mrb : * <span class="kw-2">mut </span>mrb_state , self_ : mrb_value) -&gt; mrb_value ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_exc_new (mrb : * <span class="kw-2">mut </span>mrb_state , c : * <span class="kw-2">mut </span>RClass , ptr : * <span class="kw">const </span>:: std :: os :: raw :: c_char , len : mrb_int) -&gt; mrb_value ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_exc_raise (mrb : * <span class="kw-2">mut </span>mrb_state , exc : mrb_value) ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_raise (mrb : * <span class="kw-2">mut </span>mrb_state , c : * <span class="kw-2">mut </span>RClass , msg : * <span class="kw">const </span>:: std :: os :: raw :: c_char) ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_raisef (mrb : * <span class="kw-2">mut </span>mrb_state , c : * <span class="kw-2">mut </span>RClass , fmt : * <span class="kw">const </span>:: std :: os :: raw :: c_char , ...) ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_name_error (mrb : * <span class="kw-2">mut </span>mrb_state , id : mrb_sym , fmt : * <span class="kw">const </span>:: std :: os :: raw :: c_char , ...) ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_frozen_error (mrb : * <span class="kw-2">mut </span>mrb_state , frozen_obj : * <span class="kw-2">mut </span>:: std :: os :: raw :: c_void) ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_argnum_error (mrb : * <span class="kw-2">mut </span>mrb_state , argc : mrb_int , min : :: std :: os :: raw :: c_int , max : :: std :: os :: raw :: c_int) ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_warn (mrb : * <span class="kw-2">mut </span>mrb_state , fmt : * <span class="kw">const </span>:: std :: os :: raw :: c_char , ...) ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_bug (mrb : * <span class="kw-2">mut </span>mrb_state , fmt : * <span class="kw">const </span>:: std :: os :: raw :: c_char , ...) ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_print_backtrace (mrb : * <span class="kw-2">mut </span>mrb_state) ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_print_error (mrb : * <span class="kw-2">mut </span>mrb_state) ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_vformat (mrb : * <span class="kw-2">mut </span>mrb_state , format : * <span class="kw">const </span>:: std :: os :: raw :: c_char , ap : * <span class="kw-2">mut </span>__va_list_tag) -&gt; mrb_value ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_yield (mrb : * <span class="kw-2">mut </span>mrb_state , b : mrb_value , arg : mrb_value) -&gt; mrb_value ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_yield_argv (mrb : * <span class="kw-2">mut </span>mrb_state , b : mrb_value , argc : mrb_int , argv : * <span class="kw">const </span>mrb_value) -&gt; mrb_value ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_yield_with_class (mrb : * <span class="kw-2">mut </span>mrb_state , b : mrb_value , argc : mrb_int , argv : * <span class="kw">const </span>mrb_value , self_ : mrb_value , c : * <span class="kw-2">mut </span>RClass) -&gt; mrb_value ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_yield_cont (mrb : * <span class="kw-2">mut </span>mrb_state , b : mrb_value , self_ : mrb_value , argc : mrb_int , argv : * <span class="kw">const </span>mrb_value) -&gt; mrb_value ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_gc_protect (mrb : * <span class="kw-2">mut </span>mrb_state , obj : mrb_value) ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_gc_register (mrb : * <span class="kw-2">mut </span>mrb_state , obj : mrb_value) ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_gc_unregister (mrb : * <span class="kw-2">mut </span>mrb_state , obj : mrb_value) ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_ensure_array_type (mrb : * <span class="kw-2">mut </span>mrb_state , self_ : mrb_value) -&gt; mrb_value ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_check_array_type (mrb : * <span class="kw-2">mut </span>mrb_state , self_ : mrb_value) -&gt; mrb_value ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_ensure_hash_type (mrb : * <span class="kw-2">mut </span>mrb_state , hash : mrb_value) -&gt; mrb_value ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_check_hash_type (mrb : * <span class="kw-2">mut </span>mrb_state , hash : mrb_value) -&gt; mrb_value ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_ensure_string_type (mrb : * <span class="kw-2">mut </span>mrb_state , str_ : mrb_value) -&gt; mrb_value ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_check_string_type (mrb : * <span class="kw-2">mut </span>mrb_state , str_ : mrb_value) -&gt; mrb_value ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_ensure_integer_type (mrb : * <span class="kw-2">mut </span>mrb_state , val : mrb_value) -&gt; mrb_value ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_ensure_int_type (mrb : * <span class="kw-2">mut </span>mrb_state , val : mrb_value) -&gt; mrb_value ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_check_type (mrb : * <span class="kw-2">mut </span>mrb_state , x : mrb_value , t : mrb_vtype) ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_define_alias (mrb : * <span class="kw-2">mut </span>mrb_state , c : * <span class="kw-2">mut </span>RClass , a : * <span class="kw">const </span>:: std :: os :: raw :: c_char , b : * <span class="kw">const </span>:: std :: os :: raw :: c_char) ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_define_alias_id (mrb : * <span class="kw-2">mut </span>mrb_state , c : * <span class="kw-2">mut </span>RClass , a : mrb_sym , b : mrb_sym) ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_class_name (mrb : * <span class="kw-2">mut </span>mrb_state , klass : * <span class="kw-2">mut </span>RClass) -&gt; * <span class="kw">const </span>:: std :: os :: raw :: c_char ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_define_global_const (mrb : * <span class="kw-2">mut </span>mrb_state , name : * <span class="kw">const </span>:: std :: os :: raw :: c_char , val : mrb_value) ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_attr_get (mrb : * <span class="kw-2">mut </span>mrb_state , obj : mrb_value , id : mrb_sym) -&gt; mrb_value ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_respond_to (mrb : * <span class="kw-2">mut </span>mrb_state , obj : mrb_value , mid : mrb_sym) -&gt; mrb_bool ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_obj_is_instance_of (mrb : * <span class="kw-2">mut </span>mrb_state , obj : mrb_value , c : * <span class="kw-2">mut </span>RClass) -&gt; mrb_bool ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_func_basic_p (mrb : * <span class="kw-2">mut </span>mrb_state , obj : mrb_value , mid : mrb_sym , func : mrb_func_t) -&gt; mrb_bool ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_fiber_resume (mrb : * <span class="kw-2">mut </span>mrb_state , fib : mrb_value , argc : mrb_int , argv : * <span class="kw">const </span>mrb_value) -&gt; mrb_value ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_fiber_yield (mrb : * <span class="kw-2">mut </span>mrb_state , argc : mrb_int , argv : * <span class="kw">const </span>mrb_value) -&gt; mrb_value ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_fiber_alive_p (mrb : * <span class="kw-2">mut </span>mrb_state , fib : mrb_value) -&gt; mrb_value ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_stack_extend (arg1 : * <span class="kw-2">mut </span>mrb_state , arg2 : mrb_int) ; } # [repr (C)] # [derive (Debug , Copy , Clone)] <span class="kw">pub struct </span>mrb_pool { _unused : [u8 ; <span class="number">0</span>] , } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_pool_open (arg1 : * <span class="kw-2">mut </span>mrb_state) -&gt; * <span class="kw-2">mut </span>mrb_pool ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_pool_close (arg1 : * <span class="kw-2">mut </span>mrb_pool) ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_pool_alloc (arg1 : * <span class="kw-2">mut </span>mrb_pool , arg2 : usize) -&gt; * <span class="kw-2">mut </span>:: std :: os :: raw :: c_void ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_pool_realloc (arg1 : * <span class="kw-2">mut </span>mrb_pool , arg2 : * <span class="kw-2">mut </span>:: std :: os :: raw :: c_void , oldlen : usize , newlen : usize) -&gt; * <span class="kw-2">mut </span>:: std :: os :: raw :: c_void ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_pool_can_realloc (arg1 : * <span class="kw-2">mut </span>mrb_pool , arg2 : * <span class="kw-2">mut </span>:: std :: os :: raw :: c_void , arg3 : usize) -&gt; mrb_bool ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_alloca (mrb : * <span class="kw-2">mut </span>mrb_state , arg1 : usize) -&gt; * <span class="kw-2">mut </span>:: std :: os :: raw :: c_void ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_state_atexit (mrb : * <span class="kw-2">mut </span>mrb_state , func : mrb_atexit_func) ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_show_version (mrb : * <span class="kw-2">mut </span>mrb_state) ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_show_copyright (mrb : * <span class="kw-2">mut </span>mrb_state) ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_format (mrb : * <span class="kw-2">mut </span>mrb_state , format : * <span class="kw">const </span>:: std :: os :: raw :: c_char , ...) -&gt; mrb_value ; } # [repr (C)] # [derive (Debug , Copy , Clone)] <span class="kw">pub struct </span>mrb_shared_array { <span class="kw">pub </span>refcnt : :: std :: os :: raw :: c_int , <span class="kw">pub </span>len : mrb_ssize , <span class="kw">pub </span>ptr : * <span class="kw-2">mut </span>mrb_value , } # [test] <span class="kw">fn </span>bindgen_test_layout_mrb_shared_array () { <span class="kw">const </span>UNINIT : :: std :: mem :: MaybeUninit &lt; mrb_shared_array &gt; = :: std :: mem :: MaybeUninit :: uninit () ; <span class="kw">let </span>ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: &lt; mrb_shared_array &gt; () , <span class="number">24usize </span>, concat ! (<span class="string">"Size of: " </span>, stringify ! (mrb_shared_array))) ; assert_eq ! (:: std :: mem :: align_of :: &lt; mrb_shared_array &gt; () , <span class="number">8usize </span>, concat ! (<span class="string">"Alignment of " </span>, stringify ! (mrb_shared_array))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . refcnt) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">0usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (mrb_shared_array) , <span class="string">"::" </span>, stringify ! (refcnt))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . len) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">8usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (mrb_shared_array) , <span class="string">"::" </span>, stringify ! (len))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . ptr) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">16usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (mrb_shared_array) , <span class="string">"::" </span>, stringify ! (ptr))) ; } # [repr (C)] # [derive (Copy , Clone)] <span class="kw">pub struct </span>RArray { <span class="kw">pub </span>c : * <span class="kw-2">mut </span>RClass , <span class="kw">pub </span>gcnext : * <span class="kw-2">mut </span>RBasic , <span class="kw">pub </span>_bitfield_align_1 : [u32 ; <span class="number">0</span>] , <span class="kw">pub </span>_bitfield_1 : __BindgenBitfieldUnit &lt; [u8 ; <span class="number">4usize</span>] &gt; , <span class="kw">pub </span>as_ : RArray__bindgen_ty_1 , } # [repr (C)] # [derive (Copy , Clone)] <span class="kw">pub union </span>RArray__bindgen_ty_1 { <span class="kw">pub </span>heap : RArray__bindgen_ty_1__bindgen_ty_1 , } # [repr (C)] # [derive (Copy , Clone)] <span class="kw">pub struct </span>RArray__bindgen_ty_1__bindgen_ty_1 { <span class="kw">pub </span>len : mrb_ssize , <span class="kw">pub </span>aux : RArray__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 , <span class="kw">pub </span>ptr : * <span class="kw-2">mut </span>mrb_value , } # [repr (C)] # [derive (Copy , Clone)] <span class="kw">pub union </span>RArray__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 { <span class="kw">pub </span>capa : mrb_ssize , <span class="kw">pub </span>shared : * <span class="kw-2">mut </span>mrb_shared_array , } # [test] <span class="kw">fn </span>bindgen_test_layout_RArray__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 () { <span class="kw">const </span>UNINIT : :: std :: mem :: MaybeUninit &lt; RArray__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 &gt; = :: std :: mem :: MaybeUninit :: uninit () ; <span class="kw">let </span>ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: &lt; RArray__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 &gt; () , <span class="number">8usize </span>, concat ! (<span class="string">"Size of: " </span>, stringify ! (RArray__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1))) ; assert_eq ! (:: std :: mem :: align_of :: &lt; RArray__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 &gt; () , <span class="number">8usize </span>, concat ! (<span class="string">"Alignment of " </span>, stringify ! (RArray__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . capa) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">0usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (RArray__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1) , <span class="string">"::" </span>, stringify ! (capa))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . shared) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">0usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (RArray__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1) , <span class="string">"::" </span>, stringify ! (shared))) ; } # [test] <span class="kw">fn </span>bindgen_test_layout_RArray__bindgen_ty_1__bindgen_ty_1 () { <span class="kw">const </span>UNINIT : :: std :: mem :: MaybeUninit &lt; RArray__bindgen_ty_1__bindgen_ty_1 &gt; = :: std :: mem :: MaybeUninit :: uninit () ; <span class="kw">let </span>ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: &lt; RArray__bindgen_ty_1__bindgen_ty_1 &gt; () , <span class="number">24usize </span>, concat ! (<span class="string">"Size of: " </span>, stringify ! (RArray__bindgen_ty_1__bindgen_ty_1))) ; assert_eq ! (:: std :: mem :: align_of :: &lt; RArray__bindgen_ty_1__bindgen_ty_1 &gt; () , <span class="number">8usize </span>, concat ! (<span class="string">"Alignment of " </span>, stringify ! (RArray__bindgen_ty_1__bindgen_ty_1))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . len) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">0usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (RArray__bindgen_ty_1__bindgen_ty_1) , <span class="string">"::" </span>, stringify ! (len))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . aux) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">8usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (RArray__bindgen_ty_1__bindgen_ty_1) , <span class="string">"::" </span>, stringify ! (aux))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . ptr) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">16usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (RArray__bindgen_ty_1__bindgen_ty_1) , <span class="string">"::" </span>, stringify ! (ptr))) ; } # [test] <span class="kw">fn </span>bindgen_test_layout_RArray__bindgen_ty_1 () { <span class="kw">const </span>UNINIT : :: std :: mem :: MaybeUninit &lt; RArray__bindgen_ty_1 &gt; = :: std :: mem :: MaybeUninit :: uninit () ; <span class="kw">let </span>ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: &lt; RArray__bindgen_ty_1 &gt; () , <span class="number">24usize </span>, concat ! (<span class="string">"Size of: " </span>, stringify ! (RArray__bindgen_ty_1))) ; assert_eq ! (:: std :: mem :: align_of :: &lt; RArray__bindgen_ty_1 &gt; () , <span class="number">8usize </span>, concat ! (<span class="string">"Alignment of " </span>, stringify ! (RArray__bindgen_ty_1))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . heap) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">0usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (RArray__bindgen_ty_1) , <span class="string">"::" </span>, stringify ! (heap))) ; } # [test] <span class="kw">fn </span>bindgen_test_layout_RArray () { <span class="kw">const </span>UNINIT : :: std :: mem :: MaybeUninit &lt; RArray &gt; = :: std :: mem :: MaybeUninit :: uninit () ; <span class="kw">let </span>ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: &lt; RArray &gt; () , <span class="number">48usize </span>, concat ! (<span class="string">"Size of: " </span>, stringify ! (RArray))) ; assert_eq ! (:: std :: mem :: align_of :: &lt; RArray &gt; () , <span class="number">8usize </span>, concat ! (<span class="string">"Alignment of " </span>, stringify ! (RArray))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . c) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">0usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (RArray) , <span class="string">"::" </span>, stringify ! (c))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . gcnext) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">8usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (RArray) , <span class="string">"::" </span>, stringify ! (gcnext))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . as_) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">24usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (RArray) , <span class="string">"::" </span>, stringify ! (as_))) ; } <span class="kw">impl </span>RArray { # [inline] <span class="kw">pub fn </span>tt (&amp; <span class="self">self</span>) -&gt; mrb_vtype { <span class="kw">unsafe </span>{ :: std :: mem :: transmute (<span class="self">self </span>. _bitfield_1 . get (<span class="number">0usize </span>, <span class="number">8u8</span>) <span class="kw">as </span>u32) } } # [inline] <span class="kw">pub fn </span>set_tt (&amp; <span class="kw-2">mut </span><span class="self">self </span>, val : mrb_vtype) { <span class="kw">unsafe </span>{ <span class="kw">let </span>val : u32 = :: std :: mem :: transmute (val) ; <span class="self">self </span>. _bitfield_1 . set (<span class="number">0usize </span>, <span class="number">8u8 </span>, val <span class="kw">as </span>u64) } } # [inline] <span class="kw">pub fn </span>color (&amp; <span class="self">self</span>) -&gt; u32 { <span class="kw">unsafe </span>{ :: std :: mem :: transmute (<span class="self">self </span>. _bitfield_1 . get (<span class="number">8usize </span>, <span class="number">3u8</span>) <span class="kw">as </span>u32) } } # [inline] <span class="kw">pub fn </span>set_color (&amp; <span class="kw-2">mut </span><span class="self">self </span>, val : u32) { <span class="kw">unsafe </span>{ <span class="kw">let </span>val : u32 = :: std :: mem :: transmute (val) ; <span class="self">self </span>. _bitfield_1 . set (<span class="number">8usize </span>, <span class="number">3u8 </span>, val <span class="kw">as </span>u64) } } # [inline] <span class="kw">pub fn </span>flags (&amp; <span class="self">self</span>) -&gt; u32 { <span class="kw">unsafe </span>{ :: std :: mem :: transmute (<span class="self">self </span>. _bitfield_1 . get (<span class="number">11usize </span>, <span class="number">21u8</span>) <span class="kw">as </span>u32) } } # [inline] <span class="kw">pub fn </span>set_flags (&amp; <span class="kw-2">mut </span><span class="self">self </span>, val : u32) { <span class="kw">unsafe </span>{ <span class="kw">let </span>val : u32 = :: std :: mem :: transmute (val) ; <span class="self">self </span>. _bitfield_1 . set (<span class="number">11usize </span>, <span class="number">21u8 </span>, val <span class="kw">as </span>u64) } } # [inline] <span class="kw">pub fn </span>new_bitfield_1 (tt : mrb_vtype , color : u32 , flags : u32) -&gt; __BindgenBitfieldUnit &lt; [u8 ; <span class="number">4usize</span>] &gt; { <span class="kw">let </span><span class="kw-2">mut </span>__bindgen_bitfield_unit : __BindgenBitfieldUnit &lt; [u8 ; <span class="number">4usize</span>] &gt; = Default :: default () ; __bindgen_bitfield_unit . set (<span class="number">0usize </span>, <span class="number">8u8 </span>, { <span class="kw">let </span>tt : u32 = <span class="kw">unsafe </span>{ :: std :: mem :: transmute (tt) } ; tt <span class="kw">as </span>u64 }) ; __bindgen_bitfield_unit . set (<span class="number">8usize </span>, <span class="number">3u8 </span>, { <span class="kw">let </span>color : u32 = <span class="kw">unsafe </span>{ :: std :: mem :: transmute (color) } ; color <span class="kw">as </span>u64 }) ; __bindgen_bitfield_unit . set (<span class="number">11usize </span>, <span class="number">21u8 </span>, { <span class="kw">let </span>flags : u32 = <span class="kw">unsafe </span>{ :: std :: mem :: transmute (flags) } ; flags <span class="kw">as </span>u64 }) ; __bindgen_bitfield_unit } } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_ary_modify (arg1 : * <span class="kw-2">mut </span>mrb_state , arg2 : * <span class="kw-2">mut </span>RArray) ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_ary_new_capa (arg1 : * <span class="kw-2">mut </span>mrb_state , arg2 : mrb_int) -&gt; mrb_value ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_ary_new (mrb : * <span class="kw-2">mut </span>mrb_state) -&gt; mrb_value ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_ary_new_from_values (mrb : * <span class="kw-2">mut </span>mrb_state , size : mrb_int , vals : * <span class="kw">const </span>mrb_value) -&gt; mrb_value ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_assoc_new (mrb : * <span class="kw-2">mut </span>mrb_state , car : mrb_value , cdr : mrb_value) -&gt; mrb_value ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_ary_concat (mrb : * <span class="kw-2">mut </span>mrb_state , self_ : mrb_value , other : mrb_value) ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_ary_splat (mrb : * <span class="kw-2">mut </span>mrb_state , value : mrb_value) -&gt; mrb_value ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_ary_push (mrb : * <span class="kw-2">mut </span>mrb_state , array : mrb_value , value : mrb_value) ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_ary_pop (mrb : * <span class="kw-2">mut </span>mrb_state , ary : mrb_value) -&gt; mrb_value ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_ary_set (mrb : * <span class="kw-2">mut </span>mrb_state , ary : mrb_value , n : mrb_int , val : mrb_value) ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_ary_replace (mrb : * <span class="kw-2">mut </span>mrb_state , self_ : mrb_value , other : mrb_value) ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_ary_unshift (mrb : * <span class="kw-2">mut </span>mrb_state , self_ : mrb_value , item : mrb_value) -&gt; mrb_value ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_ary_entry (ary : mrb_value , offset : mrb_int) -&gt; mrb_value ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_ary_splice (mrb : * <span class="kw-2">mut </span>mrb_state , self_ : mrb_value , head : mrb_int , len : mrb_int , rpl : mrb_value) -&gt; mrb_value ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_ary_shift (mrb : * <span class="kw-2">mut </span>mrb_state , self_ : mrb_value) -&gt; mrb_value ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_ary_clear (mrb : * <span class="kw-2">mut </span>mrb_state , self_ : mrb_value) -&gt; mrb_value ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_ary_join (mrb : * <span class="kw-2">mut </span>mrb_state , ary : mrb_value , sep : mrb_value) -&gt; mrb_value ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_ary_resize (mrb : * <span class="kw-2">mut </span>mrb_state , ary : mrb_value , new_len : mrb_int) -&gt; mrb_value ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_ary_artichoke_free (mrb : * <span class="kw-2">mut </span>mrb_state , ary : * <span class="kw-2">mut </span>RArray) ; } # [repr (C)] # [derive (Debug , Copy , Clone)] <span class="kw">pub struct </span>RClass { <span class="kw">pub </span>c : * <span class="kw-2">mut </span>RClass , <span class="kw">pub </span>gcnext : * <span class="kw-2">mut </span>RBasic , <span class="kw">pub </span>_bitfield_align_1 : [u32 ; <span class="number">0</span>] , <span class="kw">pub </span>_bitfield_1 : __BindgenBitfieldUnit &lt; [u8 ; <span class="number">4usize</span>] &gt; , <span class="kw">pub </span>iv : * <span class="kw-2">mut </span>iv_tbl , <span class="kw">pub </span>mt : * <span class="kw-2">mut </span>mt_tbl , <span class="kw">pub </span>super_ : * <span class="kw-2">mut </span>RClass , } # [test] <span class="kw">fn </span>bindgen_test_layout_RClass () { <span class="kw">const </span>UNINIT : :: std :: mem :: MaybeUninit &lt; RClass &gt; = :: std :: mem :: MaybeUninit :: uninit () ; <span class="kw">let </span>ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: &lt; RClass &gt; () , <span class="number">48usize </span>, concat ! (<span class="string">"Size of: " </span>, stringify ! (RClass))) ; assert_eq ! (:: std :: mem :: align_of :: &lt; RClass &gt; () , <span class="number">8usize </span>, concat ! (<span class="string">"Alignment of " </span>, stringify ! (RClass))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . c) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">0usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (RClass) , <span class="string">"::" </span>, stringify ! (c))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . gcnext) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">8usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (RClass) , <span class="string">"::" </span>, stringify ! (gcnext))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . iv) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">24usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (RClass) , <span class="string">"::" </span>, stringify ! (iv))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . mt) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">32usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (RClass) , <span class="string">"::" </span>, stringify ! (mt))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . super_) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">40usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (RClass) , <span class="string">"::" </span>, stringify ! (super_))) ; } <span class="kw">impl </span>RClass { # [inline] <span class="kw">pub fn </span>tt (&amp; <span class="self">self</span>) -&gt; mrb_vtype { <span class="kw">unsafe </span>{ :: std :: mem :: transmute (<span class="self">self </span>. _bitfield_1 . get (<span class="number">0usize </span>, <span class="number">8u8</span>) <span class="kw">as </span>u32) } } # [inline] <span class="kw">pub fn </span>set_tt (&amp; <span class="kw-2">mut </span><span class="self">self </span>, val : mrb_vtype) { <span class="kw">unsafe </span>{ <span class="kw">let </span>val : u32 = :: std :: mem :: transmute (val) ; <span class="self">self </span>. _bitfield_1 . set (<span class="number">0usize </span>, <span class="number">8u8 </span>, val <span class="kw">as </span>u64) } } # [inline] <span class="kw">pub fn </span>color (&amp; <span class="self">self</span>) -&gt; u32 { <span class="kw">unsafe </span>{ :: std :: mem :: transmute (<span class="self">self </span>. _bitfield_1 . get (<span class="number">8usize </span>, <span class="number">3u8</span>) <span class="kw">as </span>u32) } } # [inline] <span class="kw">pub fn </span>set_color (&amp; <span class="kw-2">mut </span><span class="self">self </span>, val : u32) { <span class="kw">unsafe </span>{ <span class="kw">let </span>val : u32 = :: std :: mem :: transmute (val) ; <span class="self">self </span>. _bitfield_1 . set (<span class="number">8usize </span>, <span class="number">3u8 </span>, val <span class="kw">as </span>u64) } } # [inline] <span class="kw">pub fn </span>flags (&amp; <span class="self">self</span>) -&gt; u32 { <span class="kw">unsafe </span>{ :: std :: mem :: transmute (<span class="self">self </span>. _bitfield_1 . get (<span class="number">11usize </span>, <span class="number">21u8</span>) <span class="kw">as </span>u32) } } # [inline] <span class="kw">pub fn </span>set_flags (&amp; <span class="kw-2">mut </span><span class="self">self </span>, val : u32) { <span class="kw">unsafe </span>{ <span class="kw">let </span>val : u32 = :: std :: mem :: transmute (val) ; <span class="self">self </span>. _bitfield_1 . set (<span class="number">11usize </span>, <span class="number">21u8 </span>, val <span class="kw">as </span>u64) } } # [inline] <span class="kw">pub fn </span>new_bitfield_1 (tt : mrb_vtype , color : u32 , flags : u32) -&gt; __BindgenBitfieldUnit &lt; [u8 ; <span class="number">4usize</span>] &gt; { <span class="kw">let </span><span class="kw-2">mut </span>__bindgen_bitfield_unit : __BindgenBitfieldUnit &lt; [u8 ; <span class="number">4usize</span>] &gt; = Default :: default () ; __bindgen_bitfield_unit . set (<span class="number">0usize </span>, <span class="number">8u8 </span>, { <span class="kw">let </span>tt : u32 = <span class="kw">unsafe </span>{ :: std :: mem :: transmute (tt) } ; tt <span class="kw">as </span>u64 }) ; __bindgen_bitfield_unit . set (<span class="number">8usize </span>, <span class="number">3u8 </span>, { <span class="kw">let </span>color : u32 = <span class="kw">unsafe </span>{ :: std :: mem :: transmute (color) } ; color <span class="kw">as </span>u64 }) ; __bindgen_bitfield_unit . set (<span class="number">11usize </span>, <span class="number">21u8 </span>, { <span class="kw">let </span>flags : u32 = <span class="kw">unsafe </span>{ :: std :: mem :: transmute (flags) } ; flags <span class="kw">as </span>u64 }) ; __bindgen_bitfield_unit } } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_define_method_raw (arg1 : * <span class="kw-2">mut </span>mrb_state , arg2 : * <span class="kw-2">mut </span>RClass , arg3 : mrb_sym , arg4 : mrb_method_t) ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_alias_method (arg1 : * <span class="kw-2">mut </span>mrb_state , c : * <span class="kw-2">mut </span>RClass , a : mrb_sym , b : mrb_sym) ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_remove_method (mrb : * <span class="kw-2">mut </span>mrb_state , c : * <span class="kw-2">mut </span>RClass , sym : mrb_sym) ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_method_search_vm (arg1 : * <span class="kw-2">mut </span>mrb_state , arg2 : * <span class="kw-2">mut </span>* <span class="kw-2">mut </span>RClass , arg3 : mrb_sym) -&gt; mrb_method_t ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_method_search (arg1 : * <span class="kw-2">mut </span>mrb_state , arg2 : * <span class="kw-2">mut </span>RClass , arg3 : mrb_sym) -&gt; mrb_method_t ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_class_real (cl : * <span class="kw-2">mut </span>RClass) -&gt; * <span class="kw-2">mut </span>RClass ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_mc_clear_by_class (mrb : * <span class="kw-2">mut </span>mrb_state , c : * <span class="kw-2">mut </span>RClass) ; } <span class="kw">pub type </span>mrb_mt_foreach_func = :: std :: option :: <span class="prelude-ty">Option </span>&lt; <span class="kw">unsafe extern </span><span class="string">"C" </span><span class="kw">fn </span>(arg1 : * <span class="kw-2">mut </span>mrb_state , arg2 : mrb_sym , arg3 : mrb_method_t , arg4 : * <span class="kw-2">mut </span>:: std :: os :: raw :: c_void) -&gt; :: std :: os :: raw :: c_int &gt; ; <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_mt_foreach (arg1 : * <span class="kw-2">mut </span>mrb_state , arg2 : * <span class="kw-2">mut </span>RClass , arg3 : mrb_mt_foreach_func , arg4 : * <span class="kw-2">mut </span>:: std :: os :: raw :: c_void) ; } # [repr (C)] # [derive (Debug , Copy , Clone)] <span class="kw">pub struct </span>mrbc_context { <span class="kw">pub </span>syms : * <span class="kw-2">mut </span>mrb_sym , <span class="kw">pub </span>slen : :: std :: os :: raw :: c_int , <span class="kw">pub </span>filename : * <span class="kw-2">mut </span>:: std :: os :: raw :: c_char , <span class="kw">pub </span>lineno : u16 , <span class="kw">pub </span>partial_hook : :: std :: option :: <span class="prelude-ty">Option </span>&lt; <span class="kw">unsafe extern </span><span class="string">"C" </span><span class="kw">fn </span>(arg1 : * <span class="kw-2">mut </span>mrb_parser_state) -&gt; :: std :: os :: raw :: c_int &gt; , <span class="kw">pub </span>partial_data : * <span class="kw-2">mut </span>:: std :: os :: raw :: c_void , <span class="kw">pub </span>target_class : * <span class="kw-2">mut </span>RClass , <span class="kw">pub </span>_bitfield_align_1 : [u8 ; <span class="number">0</span>] , <span class="kw">pub </span>_bitfield_1 : __BindgenBitfieldUnit &lt; [u8 ; <span class="number">1usize</span>] &gt; , <span class="kw">pub </span>upper : * <span class="kw">const </span>RProc , <span class="kw">pub </span>parser_nerr : usize , } # [test] <span class="kw">fn </span>bindgen_test_layout_mrbc_context () { <span class="kw">const </span>UNINIT : :: std :: mem :: MaybeUninit &lt; mrbc_context &gt; = :: std :: mem :: MaybeUninit :: uninit () ; <span class="kw">let </span>ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: &lt; mrbc_context &gt; () , <span class="number">80usize </span>, concat ! (<span class="string">"Size of: " </span>, stringify ! (mrbc_context))) ; assert_eq ! (:: std :: mem :: align_of :: &lt; mrbc_context &gt; () , <span class="number">8usize </span>, concat ! (<span class="string">"Alignment of " </span>, stringify ! (mrbc_context))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . syms) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">0usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (mrbc_context) , <span class="string">"::" </span>, stringify ! (syms))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . slen) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">8usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (mrbc_context) , <span class="string">"::" </span>, stringify ! (slen))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . filename) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">16usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (mrbc_context) , <span class="string">"::" </span>, stringify ! (filename))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . lineno) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">24usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (mrbc_context) , <span class="string">"::" </span>, stringify ! (lineno))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . partial_hook) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">32usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (mrbc_context) , <span class="string">"::" </span>, stringify ! (partial_hook))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . partial_data) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">40usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (mrbc_context) , <span class="string">"::" </span>, stringify ! (partial_data))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . target_class) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">48usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (mrbc_context) , <span class="string">"::" </span>, stringify ! (target_class))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . upper) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">64usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (mrbc_context) , <span class="string">"::" </span>, stringify ! (upper))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . parser_nerr) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">72usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (mrbc_context) , <span class="string">"::" </span>, stringify ! (parser_nerr))) ; } <span class="kw">impl </span>mrbc_context { # [inline] <span class="kw">pub fn </span>capture_errors (&amp; <span class="self">self</span>) -&gt; mrb_bool { <span class="kw">unsafe </span>{ :: std :: mem :: transmute (<span class="self">self </span>. _bitfield_1 . get (<span class="number">0usize </span>, <span class="number">1u8</span>) <span class="kw">as </span>u8) } } # [inline] <span class="kw">pub fn </span>set_capture_errors (&amp; <span class="kw-2">mut </span><span class="self">self </span>, val : mrb_bool) { <span class="kw">unsafe </span>{ <span class="kw">let </span>val : u8 = :: std :: mem :: transmute (val) ; <span class="self">self </span>. _bitfield_1 . set (<span class="number">0usize </span>, <span class="number">1u8 </span>, val <span class="kw">as </span>u64) } } # [inline] <span class="kw">pub fn </span>dump_result (&amp; <span class="self">self</span>) -&gt; mrb_bool { <span class="kw">unsafe </span>{ :: std :: mem :: transmute (<span class="self">self </span>. _bitfield_1 . get (<span class="number">1usize </span>, <span class="number">1u8</span>) <span class="kw">as </span>u8) } } # [inline] <span class="kw">pub fn </span>set_dump_result (&amp; <span class="kw-2">mut </span><span class="self">self </span>, val : mrb_bool) { <span class="kw">unsafe </span>{ <span class="kw">let </span>val : u8 = :: std :: mem :: transmute (val) ; <span class="self">self </span>. _bitfield_1 . set (<span class="number">1usize </span>, <span class="number">1u8 </span>, val <span class="kw">as </span>u64) } } # [inline] <span class="kw">pub fn </span>no_exec (&amp; <span class="self">self</span>) -&gt; mrb_bool { <span class="kw">unsafe </span>{ :: std :: mem :: transmute (<span class="self">self </span>. _bitfield_1 . get (<span class="number">2usize </span>, <span class="number">1u8</span>) <span class="kw">as </span>u8) } } # [inline] <span class="kw">pub fn </span>set_no_exec (&amp; <span class="kw-2">mut </span><span class="self">self </span>, val : mrb_bool) { <span class="kw">unsafe </span>{ <span class="kw">let </span>val : u8 = :: std :: mem :: transmute (val) ; <span class="self">self </span>. _bitfield_1 . set (<span class="number">2usize </span>, <span class="number">1u8 </span>, val <span class="kw">as </span>u64) } } # [inline] <span class="kw">pub fn </span>keep_lv (&amp; <span class="self">self</span>) -&gt; mrb_bool { <span class="kw">unsafe </span>{ :: std :: mem :: transmute (<span class="self">self </span>. _bitfield_1 . get (<span class="number">3usize </span>, <span class="number">1u8</span>) <span class="kw">as </span>u8) } } # [inline] <span class="kw">pub fn </span>set_keep_lv (&amp; <span class="kw-2">mut </span><span class="self">self </span>, val : mrb_bool) { <span class="kw">unsafe </span>{ <span class="kw">let </span>val : u8 = :: std :: mem :: transmute (val) ; <span class="self">self </span>. _bitfield_1 . set (<span class="number">3usize </span>, <span class="number">1u8 </span>, val <span class="kw">as </span>u64) } } # [inline] <span class="kw">pub fn </span>no_optimize (&amp; <span class="self">self</span>) -&gt; mrb_bool { <span class="kw">unsafe </span>{ :: std :: mem :: transmute (<span class="self">self </span>. _bitfield_1 . get (<span class="number">4usize </span>, <span class="number">1u8</span>) <span class="kw">as </span>u8) } } # [inline] <span class="kw">pub fn </span>set_no_optimize (&amp; <span class="kw-2">mut </span><span class="self">self </span>, val : mrb_bool) { <span class="kw">unsafe </span>{ <span class="kw">let </span>val : u8 = :: std :: mem :: transmute (val) ; <span class="self">self </span>. _bitfield_1 . set (<span class="number">4usize </span>, <span class="number">1u8 </span>, val <span class="kw">as </span>u64) } } # [inline] <span class="kw">pub fn </span>no_ext_ops (&amp; <span class="self">self</span>) -&gt; mrb_bool { <span class="kw">unsafe </span>{ :: std :: mem :: transmute (<span class="self">self </span>. _bitfield_1 . get (<span class="number">5usize </span>, <span class="number">1u8</span>) <span class="kw">as </span>u8) } } # [inline] <span class="kw">pub fn </span>set_no_ext_ops (&amp; <span class="kw-2">mut </span><span class="self">self </span>, val : mrb_bool) { <span class="kw">unsafe </span>{ <span class="kw">let </span>val : u8 = :: std :: mem :: transmute (val) ; <span class="self">self </span>. _bitfield_1 . set (<span class="number">5usize </span>, <span class="number">1u8 </span>, val <span class="kw">as </span>u64) } } # [inline] <span class="kw">pub fn </span>new_bitfield_1 (capture_errors : mrb_bool , dump_result : mrb_bool , no_exec : mrb_bool , keep_lv : mrb_bool , no_optimize : mrb_bool , no_ext_ops : mrb_bool) -&gt; __BindgenBitfieldUnit &lt; [u8 ; <span class="number">1usize</span>] &gt; { <span class="kw">let </span><span class="kw-2">mut </span>__bindgen_bitfield_unit : __BindgenBitfieldUnit &lt; [u8 ; <span class="number">1usize</span>] &gt; = Default :: default () ; __bindgen_bitfield_unit . set (<span class="number">0usize </span>, <span class="number">1u8 </span>, { <span class="kw">let </span>capture_errors : u8 = <span class="kw">unsafe </span>{ :: std :: mem :: transmute (capture_errors) } ; capture_errors <span class="kw">as </span>u64 }) ; __bindgen_bitfield_unit . set (<span class="number">1usize </span>, <span class="number">1u8 </span>, { <span class="kw">let </span>dump_result : u8 = <span class="kw">unsafe </span>{ :: std :: mem :: transmute (dump_result) } ; dump_result <span class="kw">as </span>u64 }) ; __bindgen_bitfield_unit . set (<span class="number">2usize </span>, <span class="number">1u8 </span>, { <span class="kw">let </span>no_exec : u8 = <span class="kw">unsafe </span>{ :: std :: mem :: transmute (no_exec) } ; no_exec <span class="kw">as </span>u64 }) ; __bindgen_bitfield_unit . set (<span class="number">3usize </span>, <span class="number">1u8 </span>, { <span class="kw">let </span>keep_lv : u8 = <span class="kw">unsafe </span>{ :: std :: mem :: transmute (keep_lv) } ; keep_lv <span class="kw">as </span>u64 }) ; __bindgen_bitfield_unit . set (<span class="number">4usize </span>, <span class="number">1u8 </span>, { <span class="kw">let </span>no_optimize : u8 = <span class="kw">unsafe </span>{ :: std :: mem :: transmute (no_optimize) } ; no_optimize <span class="kw">as </span>u64 }) ; __bindgen_bitfield_unit . set (<span class="number">5usize </span>, <span class="number">1u8 </span>, { <span class="kw">let </span>no_ext_ops : u8 = <span class="kw">unsafe </span>{ :: std :: mem :: transmute (no_ext_ops) } ; no_ext_ops <span class="kw">as </span>u64 }) ; __bindgen_bitfield_unit } } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrbc_context_new (mrb : * <span class="kw-2">mut </span>mrb_state) -&gt; * <span class="kw-2">mut </span>mrbc_context ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrbc_context_free (mrb : * <span class="kw-2">mut </span>mrb_state , cxt : * <span class="kw-2">mut </span>mrbc_context) ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrbc_filename (mrb : * <span class="kw-2">mut </span>mrb_state , c : * <span class="kw-2">mut </span>mrbc_context , s : * <span class="kw">const </span>:: std :: os :: raw :: c_char) -&gt; * <span class="kw">const </span>:: std :: os :: raw :: c_char ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrbc_partial_hook (mrb : * <span class="kw-2">mut </span>mrb_state , c : * <span class="kw-2">mut </span>mrbc_context , partial_hook : :: std :: option :: <span class="prelude-ty">Option </span>&lt; <span class="kw">unsafe extern </span><span class="string">"C" </span><span class="kw">fn </span>(arg1 : * <span class="kw-2">mut </span>mrb_parser_state) -&gt; :: std :: os :: raw :: c_int &gt; , data : * <span class="kw-2">mut </span>:: std :: os :: raw :: c_void) ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrbc_cleanup_local_variables (mrb : * <span class="kw-2">mut </span>mrb_state , c : * <span class="kw-2">mut </span>mrbc_context) ; } # [repr (C)] # [derive (Debug , Copy , Clone)] <span class="kw">pub struct </span>mrb_ast_node { <span class="kw">pub </span>car : * <span class="kw-2">mut </span>mrb_ast_node , <span class="kw">pub </span>cdr : * <span class="kw-2">mut </span>mrb_ast_node , <span class="kw">pub </span>lineno : u16 , <span class="kw">pub </span>filename_index : u16 , } # [test] <span class="kw">fn </span>bindgen_test_layout_mrb_ast_node () { <span class="kw">const </span>UNINIT : :: std :: mem :: MaybeUninit &lt; mrb_ast_node &gt; = :: std :: mem :: MaybeUninit :: uninit () ; <span class="kw">let </span>ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: &lt; mrb_ast_node &gt; () , <span class="number">24usize </span>, concat ! (<span class="string">"Size of: " </span>, stringify ! (mrb_ast_node))) ; assert_eq ! (:: std :: mem :: align_of :: &lt; mrb_ast_node &gt; () , <span class="number">8usize </span>, concat ! (<span class="string">"Alignment of " </span>, stringify ! (mrb_ast_node))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . car) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">0usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (mrb_ast_node) , <span class="string">"::" </span>, stringify ! (car))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . cdr) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">8usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (mrb_ast_node) , <span class="string">"::" </span>, stringify ! (cdr))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . lineno) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">16usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (mrb_ast_node) , <span class="string">"::" </span>, stringify ! (lineno))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . filename_index) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">18usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (mrb_ast_node) , <span class="string">"::" </span>, stringify ! (filename_index))) ; } # [repr (u32)] # [derive (Debug , Copy , Clone , Hash , PartialEq , Eq)] <span class="kw">pub enum </span>mrb_lex_state_enum { EXPR_BEG = <span class="number">0 </span>, EXPR_END = <span class="number">1 </span>, EXPR_ENDARG = <span class="number">2 </span>, EXPR_ENDFN = <span class="number">3 </span>, EXPR_ARG = <span class="number">4 </span>, EXPR_CMDARG = <span class="number">5 </span>, EXPR_MID = <span class="number">6 </span>, EXPR_FNAME = <span class="number">7 </span>, EXPR_DOT = <span class="number">8 </span>, EXPR_CLASS = <span class="number">9 </span>, EXPR_VALUE = <span class="number">10 </span>, EXPR_MAX_STATE = <span class="number">11 </span>, } # [repr (C)] # [derive (Debug , Copy , Clone)] <span class="kw">pub struct </span>mrb_parser_message { <span class="kw">pub </span>lineno : u16 , <span class="kw">pub </span>column : :: std :: os :: raw :: c_int , <span class="kw">pub </span>message : * <span class="kw-2">mut </span>:: std :: os :: raw :: c_char , } # [test] <span class="kw">fn </span>bindgen_test_layout_mrb_parser_message () { <span class="kw">const </span>UNINIT : :: std :: mem :: MaybeUninit &lt; mrb_parser_message &gt; = :: std :: mem :: MaybeUninit :: uninit () ; <span class="kw">let </span>ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: &lt; mrb_parser_message &gt; () , <span class="number">16usize </span>, concat ! (<span class="string">"Size of: " </span>, stringify ! (mrb_parser_message))) ; assert_eq ! (:: std :: mem :: align_of :: &lt; mrb_parser_message &gt; () , <span class="number">8usize </span>, concat ! (<span class="string">"Alignment of " </span>, stringify ! (mrb_parser_message))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . lineno) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">0usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (mrb_parser_message) , <span class="string">"::" </span>, stringify ! (lineno))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . column) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">4usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (mrb_parser_message) , <span class="string">"::" </span>, stringify ! (column))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . message) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">8usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (mrb_parser_message) , <span class="string">"::" </span>, stringify ! (message))) ; } # [repr (u32)] # [derive (Debug , Copy , Clone , Hash , PartialEq , Eq)] <span class="kw">pub enum </span>mrb_string_type { str_not_parsing = <span class="number">0 </span>, str_squote = <span class="number">1 </span>, str_dquote = <span class="number">3 </span>, str_regexp = <span class="number">7 </span>, str_sword = <span class="number">41 </span>, str_dword = <span class="number">43 </span>, str_ssym = <span class="number">17 </span>, str_ssymbols = <span class="number">49 </span>, str_dsymbols = <span class="number">51 </span>, str_heredoc = <span class="number">65 </span>, str_xquote = <span class="number">131 </span>, } # [repr (C)] # [derive (Debug , Copy , Clone)] <span class="kw">pub struct </span>mrb_parser_heredoc_info { <span class="kw">pub </span>_bitfield_align_1 : [u8 ; <span class="number">0</span>] , <span class="kw">pub </span>_bitfield_1 : __BindgenBitfieldUnit &lt; [u8 ; <span class="number">1usize</span>] &gt; , <span class="kw">pub </span>indent : usize , <span class="kw">pub </span>indented : * <span class="kw-2">mut </span>mrb_ast_node , <span class="kw">pub </span>type_ : mrb_string_type , <span class="kw">pub </span>term : * <span class="kw">const </span>:: std :: os :: raw :: c_char , <span class="kw">pub </span>term_len : :: std :: os :: raw :: c_int , <span class="kw">pub </span>doc : * <span class="kw-2">mut </span>mrb_ast_node , } # [test] <span class="kw">fn </span>bindgen_test_layout_mrb_parser_heredoc_info () { <span class="kw">const </span>UNINIT : :: std :: mem :: MaybeUninit &lt; mrb_parser_heredoc_info &gt; = :: std :: mem :: MaybeUninit :: uninit () ; <span class="kw">let </span>ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: &lt; mrb_parser_heredoc_info &gt; () , <span class="number">56usize </span>, concat ! (<span class="string">"Size of: " </span>, stringify ! (mrb_parser_heredoc_info))) ; assert_eq ! (:: std :: mem :: align_of :: &lt; mrb_parser_heredoc_info &gt; () , <span class="number">8usize </span>, concat ! (<span class="string">"Alignment of " </span>, stringify ! (mrb_parser_heredoc_info))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . indent) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">8usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (mrb_parser_heredoc_info) , <span class="string">"::" </span>, stringify ! (indent))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . indented) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">16usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (mrb_parser_heredoc_info) , <span class="string">"::" </span>, stringify ! (indented))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . type_) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">24usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (mrb_parser_heredoc_info) , <span class="string">"::" </span>, stringify ! (type_))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . term) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">32usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (mrb_parser_heredoc_info) , <span class="string">"::" </span>, stringify ! (term))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . term_len) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">40usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (mrb_parser_heredoc_info) , <span class="string">"::" </span>, stringify ! (term_len))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . doc) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">48usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (mrb_parser_heredoc_info) , <span class="string">"::" </span>, stringify ! (doc))) ; } <span class="kw">impl </span>mrb_parser_heredoc_info { # [inline] <span class="kw">pub fn </span>allow_indent (&amp; <span class="self">self</span>) -&gt; mrb_bool { <span class="kw">unsafe </span>{ :: std :: mem :: transmute (<span class="self">self </span>. _bitfield_1 . get (<span class="number">0usize </span>, <span class="number">1u8</span>) <span class="kw">as </span>u8) } } # [inline] <span class="kw">pub fn </span>set_allow_indent (&amp; <span class="kw-2">mut </span><span class="self">self </span>, val : mrb_bool) { <span class="kw">unsafe </span>{ <span class="kw">let </span>val : u8 = :: std :: mem :: transmute (val) ; <span class="self">self </span>. _bitfield_1 . set (<span class="number">0usize </span>, <span class="number">1u8 </span>, val <span class="kw">as </span>u64) } } # [inline] <span class="kw">pub fn </span>remove_indent (&amp; <span class="self">self</span>) -&gt; mrb_bool { <span class="kw">unsafe </span>{ :: std :: mem :: transmute (<span class="self">self </span>. _bitfield_1 . get (<span class="number">1usize </span>, <span class="number">1u8</span>) <span class="kw">as </span>u8) } } # [inline] <span class="kw">pub fn </span>set_remove_indent (&amp; <span class="kw-2">mut </span><span class="self">self </span>, val : mrb_bool) { <span class="kw">unsafe </span>{ <span class="kw">let </span>val : u8 = :: std :: mem :: transmute (val) ; <span class="self">self </span>. _bitfield_1 . set (<span class="number">1usize </span>, <span class="number">1u8 </span>, val <span class="kw">as </span>u64) } } # [inline] <span class="kw">pub fn </span>line_head (&amp; <span class="self">self</span>) -&gt; mrb_bool { <span class="kw">unsafe </span>{ :: std :: mem :: transmute (<span class="self">self </span>. _bitfield_1 . get (<span class="number">2usize </span>, <span class="number">1u8</span>) <span class="kw">as </span>u8) } } # [inline] <span class="kw">pub fn </span>set_line_head (&amp; <span class="kw-2">mut </span><span class="self">self </span>, val : mrb_bool) { <span class="kw">unsafe </span>{ <span class="kw">let </span>val : u8 = :: std :: mem :: transmute (val) ; <span class="self">self </span>. _bitfield_1 . set (<span class="number">2usize </span>, <span class="number">1u8 </span>, val <span class="kw">as </span>u64) } } # [inline] <span class="kw">pub fn </span>new_bitfield_1 (allow_indent : mrb_bool , remove_indent : mrb_bool , line_head : mrb_bool) -&gt; __BindgenBitfieldUnit &lt; [u8 ; <span class="number">1usize</span>] &gt; { <span class="kw">let </span><span class="kw-2">mut </span>__bindgen_bitfield_unit : __BindgenBitfieldUnit &lt; [u8 ; <span class="number">1usize</span>] &gt; = Default :: default () ; __bindgen_bitfield_unit . set (<span class="number">0usize </span>, <span class="number">1u8 </span>, { <span class="kw">let </span>allow_indent : u8 = <span class="kw">unsafe </span>{ :: std :: mem :: transmute (allow_indent) } ; allow_indent <span class="kw">as </span>u64 }) ; __bindgen_bitfield_unit . set (<span class="number">1usize </span>, <span class="number">1u8 </span>, { <span class="kw">let </span>remove_indent : u8 = <span class="kw">unsafe </span>{ :: std :: mem :: transmute (remove_indent) } ; remove_indent <span class="kw">as </span>u64 }) ; __bindgen_bitfield_unit . set (<span class="number">2usize </span>, <span class="number">1u8 </span>, { <span class="kw">let </span>line_head : u8 = <span class="kw">unsafe </span>{ :: std :: mem :: transmute (line_head) } ; line_head <span class="kw">as </span>u64 }) ; __bindgen_bitfield_unit } } # [repr (C)] # [derive (Debug , Copy , Clone)] <span class="kw">pub struct </span>mrb_parser_state { <span class="kw">pub </span>mrb : * <span class="kw-2">mut </span>mrb_state , <span class="kw">pub </span>pool : * <span class="kw-2">mut </span>mrb_pool , <span class="kw">pub </span>cells : * <span class="kw-2">mut </span>mrb_ast_node , <span class="kw">pub </span>s : * <span class="kw">const </span>:: std :: os :: raw :: c_char , <span class="kw">pub </span>send : * <span class="kw">const </span>:: std :: os :: raw :: c_char , <span class="kw">pub </span>cxt : * <span class="kw-2">mut </span>mrbc_context , <span class="kw">pub </span>filename_sym : mrb_sym , <span class="kw">pub </span>lineno : u16 , <span class="kw">pub </span>column : :: std :: os :: raw :: c_int , <span class="kw">pub </span>lstate : mrb_lex_state_enum , <span class="kw">pub </span>lex_strterm : * <span class="kw-2">mut </span>parser_lex_strterm , <span class="kw">pub </span>cond_stack : :: std :: os :: raw :: c_uint , <span class="kw">pub </span>cmdarg_stack : :: std :: os :: raw :: c_uint , <span class="kw">pub </span>paren_nest : :: std :: os :: raw :: c_int , <span class="kw">pub </span>lpar_beg : :: std :: os :: raw :: c_int , <span class="kw">pub </span>in_def : :: std :: os :: raw :: c_int , <span class="kw">pub </span>in_single : :: std :: os :: raw :: c_int , <span class="kw">pub </span>_bitfield_align_1 : [u8 ; <span class="number">0</span>] , <span class="kw">pub </span>_bitfield_1 : __BindgenBitfieldUnit &lt; [u8 ; <span class="number">1usize</span>] &gt; , <span class="kw">pub </span>locals : * <span class="kw-2">mut </span>mrb_ast_node , <span class="kw">pub </span>pb : * <span class="kw-2">mut </span>mrb_ast_node , <span class="kw">pub </span>tokbuf : * <span class="kw-2">mut </span>:: std :: os :: raw :: c_char , <span class="kw">pub </span>buf : [:: std :: os :: raw :: c_char ; <span class="number">256usize</span>] , <span class="kw">pub </span>tidx : :: std :: os :: raw :: c_int , <span class="kw">pub </span>tsiz : :: std :: os :: raw :: c_int , <span class="kw">pub </span>heredocs_from_nextline : * <span class="kw-2">mut </span>mrb_ast_node , <span class="kw">pub </span>parsing_heredoc : * <span class="kw-2">mut </span>mrb_ast_node , <span class="kw">pub </span>ylval : * <span class="kw-2">mut </span>:: std :: os :: raw :: c_void , <span class="kw">pub </span>nerr : usize , <span class="kw">pub </span>nwarn : usize , <span class="kw">pub </span>tree : * <span class="kw-2">mut </span>mrb_ast_node , <span class="kw">pub </span>_bitfield_align_2 : [u8 ; <span class="number">0</span>] , <span class="kw">pub </span>_bitfield_2 : __BindgenBitfieldUnit &lt; [u8 ; <span class="number">1usize</span>] &gt; , <span class="kw">pub </span>upper : * <span class="kw">const </span>RProc , <span class="kw">pub </span>error_buffer : [mrb_parser_message ; <span class="number">10usize</span>] , <span class="kw">pub </span>warn_buffer : [mrb_parser_message ; <span class="number">10usize</span>] , <span class="kw">pub </span>filename_table : * <span class="kw-2">mut </span>mrb_sym , <span class="kw">pub </span>filename_table_length : u16 , <span class="kw">pub </span>current_filename_index : u16 , <span class="kw">pub </span>nvars : * <span class="kw-2">mut </span>mrb_ast_node , } # [test] <span class="kw">fn </span>bindgen_test_layout_mrb_parser_state () { <span class="kw">const </span>UNINIT : :: std :: mem :: MaybeUninit &lt; mrb_parser_state &gt; = :: std :: mem :: MaybeUninit :: uninit () ; <span class="kw">let </span>ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: &lt; mrb_parser_state &gt; () , <span class="number">800usize </span>, concat ! (<span class="string">"Size of: " </span>, stringify ! (mrb_parser_state))) ; assert_eq ! (:: std :: mem :: align_of :: &lt; mrb_parser_state &gt; () , <span class="number">8usize </span>, concat ! (<span class="string">"Alignment of " </span>, stringify ! (mrb_parser_state))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . mrb) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">0usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (mrb_parser_state) , <span class="string">"::" </span>, stringify ! (mrb))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . pool) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">8usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (mrb_parser_state) , <span class="string">"::" </span>, stringify ! (pool))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . cells) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">16usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (mrb_parser_state) , <span class="string">"::" </span>, stringify ! (cells))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . s) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">24usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (mrb_parser_state) , <span class="string">"::" </span>, stringify ! (s))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . send) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">32usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (mrb_parser_state) , <span class="string">"::" </span>, stringify ! (send))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . cxt) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">40usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (mrb_parser_state) , <span class="string">"::" </span>, stringify ! (cxt))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . filename_sym) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">48usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (mrb_parser_state) , <span class="string">"::" </span>, stringify ! (filename_sym))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . lineno) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">52usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (mrb_parser_state) , <span class="string">"::" </span>, stringify ! (lineno))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . column) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">56usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (mrb_parser_state) , <span class="string">"::" </span>, stringify ! (column))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . lstate) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">60usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (mrb_parser_state) , <span class="string">"::" </span>, stringify ! (lstate))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . lex_strterm) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">64usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (mrb_parser_state) , <span class="string">"::" </span>, stringify ! (lex_strterm))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . cond_stack) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">72usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (mrb_parser_state) , <span class="string">"::" </span>, stringify ! (cond_stack))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . cmdarg_stack) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">76usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (mrb_parser_state) , <span class="string">"::" </span>, stringify ! (cmdarg_stack))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . paren_nest) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">80usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (mrb_parser_state) , <span class="string">"::" </span>, stringify ! (paren_nest))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . lpar_beg) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">84usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (mrb_parser_state) , <span class="string">"::" </span>, stringify ! (lpar_beg))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . in_def) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">88usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (mrb_parser_state) , <span class="string">"::" </span>, stringify ! (in_def))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . in_single) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">92usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (mrb_parser_state) , <span class="string">"::" </span>, stringify ! (in_single))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . locals) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">104usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (mrb_parser_state) , <span class="string">"::" </span>, stringify ! (locals))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . pb) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">112usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (mrb_parser_state) , <span class="string">"::" </span>, stringify ! (pb))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . tokbuf) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">120usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (mrb_parser_state) , <span class="string">"::" </span>, stringify ! (tokbuf))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . buf) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">128usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (mrb_parser_state) , <span class="string">"::" </span>, stringify ! (buf))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . tidx) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">384usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (mrb_parser_state) , <span class="string">"::" </span>, stringify ! (tidx))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . tsiz) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">388usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (mrb_parser_state) , <span class="string">"::" </span>, stringify ! (tsiz))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . heredocs_from_nextline) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">392usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (mrb_parser_state) , <span class="string">"::" </span>, stringify ! (heredocs_from_nextline))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . parsing_heredoc) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">400usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (mrb_parser_state) , <span class="string">"::" </span>, stringify ! (parsing_heredoc))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . ylval) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">408usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (mrb_parser_state) , <span class="string">"::" </span>, stringify ! (ylval))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . nerr) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">416usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (mrb_parser_state) , <span class="string">"::" </span>, stringify ! (nerr))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . nwarn) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">424usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (mrb_parser_state) , <span class="string">"::" </span>, stringify ! (nwarn))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . tree) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">432usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (mrb_parser_state) , <span class="string">"::" </span>, stringify ! (tree))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . upper) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">448usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (mrb_parser_state) , <span class="string">"::" </span>, stringify ! (upper))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . error_buffer) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">456usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (mrb_parser_state) , <span class="string">"::" </span>, stringify ! (error_buffer))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . warn_buffer) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">616usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (mrb_parser_state) , <span class="string">"::" </span>, stringify ! (warn_buffer))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . filename_table) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">776usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (mrb_parser_state) , <span class="string">"::" </span>, stringify ! (filename_table))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . filename_table_length) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">784usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (mrb_parser_state) , <span class="string">"::" </span>, stringify ! (filename_table_length))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . current_filename_index) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">786usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (mrb_parser_state) , <span class="string">"::" </span>, stringify ! (current_filename_index))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . nvars) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">792usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (mrb_parser_state) , <span class="string">"::" </span>, stringify ! (nvars))) ; } <span class="kw">impl </span>mrb_parser_state { # [inline] <span class="kw">pub fn </span>cmd_start (&amp; <span class="self">self</span>) -&gt; mrb_bool { <span class="kw">unsafe </span>{ :: std :: mem :: transmute (<span class="self">self </span>. _bitfield_1 . get (<span class="number">0usize </span>, <span class="number">1u8</span>) <span class="kw">as </span>u8) } } # [inline] <span class="kw">pub fn </span>set_cmd_start (&amp; <span class="kw-2">mut </span><span class="self">self </span>, val : mrb_bool) { <span class="kw">unsafe </span>{ <span class="kw">let </span>val : u8 = :: std :: mem :: transmute (val) ; <span class="self">self </span>. _bitfield_1 . set (<span class="number">0usize </span>, <span class="number">1u8 </span>, val <span class="kw">as </span>u64) } } # [inline] <span class="kw">pub fn </span>new_bitfield_1 (cmd_start : mrb_bool) -&gt; __BindgenBitfieldUnit &lt; [u8 ; <span class="number">1usize</span>] &gt; { <span class="kw">let </span><span class="kw-2">mut </span>__bindgen_bitfield_unit : __BindgenBitfieldUnit &lt; [u8 ; <span class="number">1usize</span>] &gt; = Default :: default () ; __bindgen_bitfield_unit . set (<span class="number">0usize </span>, <span class="number">1u8 </span>, { <span class="kw">let </span>cmd_start : u8 = <span class="kw">unsafe </span>{ :: std :: mem :: transmute (cmd_start) } ; cmd_start <span class="kw">as </span>u64 }) ; __bindgen_bitfield_unit } # [inline] <span class="kw">pub fn </span>no_optimize (&amp; <span class="self">self</span>) -&gt; mrb_bool { <span class="kw">unsafe </span>{ :: std :: mem :: transmute (<span class="self">self </span>. _bitfield_2 . get (<span class="number">0usize </span>, <span class="number">1u8</span>) <span class="kw">as </span>u8) } } # [inline] <span class="kw">pub fn </span>set_no_optimize (&amp; <span class="kw-2">mut </span><span class="self">self </span>, val : mrb_bool) { <span class="kw">unsafe </span>{ <span class="kw">let </span>val : u8 = :: std :: mem :: transmute (val) ; <span class="self">self </span>. _bitfield_2 . set (<span class="number">0usize </span>, <span class="number">1u8 </span>, val <span class="kw">as </span>u64) } } # [inline] <span class="kw">pub fn </span>capture_errors (&amp; <span class="self">self</span>) -&gt; mrb_bool { <span class="kw">unsafe </span>{ :: std :: mem :: transmute (<span class="self">self </span>. _bitfield_2 . get (<span class="number">1usize </span>, <span class="number">1u8</span>) <span class="kw">as </span>u8) } } # [inline] <span class="kw">pub fn </span>set_capture_errors (&amp; <span class="kw-2">mut </span><span class="self">self </span>, val : mrb_bool) { <span class="kw">unsafe </span>{ <span class="kw">let </span>val : u8 = :: std :: mem :: transmute (val) ; <span class="self">self </span>. _bitfield_2 . set (<span class="number">1usize </span>, <span class="number">1u8 </span>, val <span class="kw">as </span>u64) } } # [inline] <span class="kw">pub fn </span>no_ext_ops (&amp; <span class="self">self</span>) -&gt; mrb_bool { <span class="kw">unsafe </span>{ :: std :: mem :: transmute (<span class="self">self </span>. _bitfield_2 . get (<span class="number">2usize </span>, <span class="number">1u8</span>) <span class="kw">as </span>u8) } } # [inline] <span class="kw">pub fn </span>set_no_ext_ops (&amp; <span class="kw-2">mut </span><span class="self">self </span>, val : mrb_bool) { <span class="kw">unsafe </span>{ <span class="kw">let </span>val : u8 = :: std :: mem :: transmute (val) ; <span class="self">self </span>. _bitfield_2 . set (<span class="number">2usize </span>, <span class="number">1u8 </span>, val <span class="kw">as </span>u64) } } # [inline] <span class="kw">pub fn </span>new_bitfield_2 (no_optimize : mrb_bool , capture_errors : mrb_bool , no_ext_ops : mrb_bool) -&gt; __BindgenBitfieldUnit &lt; [u8 ; <span class="number">1usize</span>] &gt; { <span class="kw">let </span><span class="kw-2">mut </span>__bindgen_bitfield_unit : __BindgenBitfieldUnit &lt; [u8 ; <span class="number">1usize</span>] &gt; = Default :: default () ; __bindgen_bitfield_unit . set (<span class="number">0usize </span>, <span class="number">1u8 </span>, { <span class="kw">let </span>no_optimize : u8 = <span class="kw">unsafe </span>{ :: std :: mem :: transmute (no_optimize) } ; no_optimize <span class="kw">as </span>u64 }) ; __bindgen_bitfield_unit . set (<span class="number">1usize </span>, <span class="number">1u8 </span>, { <span class="kw">let </span>capture_errors : u8 = <span class="kw">unsafe </span>{ :: std :: mem :: transmute (capture_errors) } ; capture_errors <span class="kw">as </span>u64 }) ; __bindgen_bitfield_unit . set (<span class="number">2usize </span>, <span class="number">1u8 </span>, { <span class="kw">let </span>no_ext_ops : u8 = <span class="kw">unsafe </span>{ :: std :: mem :: transmute (no_ext_ops) } ; no_ext_ops <span class="kw">as </span>u64 }) ; __bindgen_bitfield_unit } } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_parser_new (arg1 : * <span class="kw-2">mut </span>mrb_state) -&gt; * <span class="kw-2">mut </span>mrb_parser_state ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_parser_free (arg1 : * <span class="kw-2">mut </span>mrb_parser_state) ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_parser_parse (arg1 : * <span class="kw-2">mut </span>mrb_parser_state , arg2 : * <span class="kw-2">mut </span>mrbc_context) ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_parser_set_filename (arg1 : * <span class="kw-2">mut </span>mrb_parser_state , arg2 : * <span class="kw">const </span>:: std :: os :: raw :: c_char) ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_parser_get_filename (arg1 : * <span class="kw-2">mut </span>mrb_parser_state , idx : u16) -&gt; mrb_sym ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_parse_string (arg1 : * <span class="kw-2">mut </span>mrb_state , arg2 : * <span class="kw">const </span>:: std :: os :: raw :: c_char , arg3 : * <span class="kw-2">mut </span>mrbc_context) -&gt; * <span class="kw-2">mut </span>mrb_parser_state ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_parse_nstring (arg1 : * <span class="kw-2">mut </span>mrb_state , arg2 : * <span class="kw">const </span>:: std :: os :: raw :: c_char , arg3 : usize , arg4 : * <span class="kw-2">mut </span>mrbc_context) -&gt; * <span class="kw-2">mut </span>mrb_parser_state ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_generate_code (arg1 : * <span class="kw-2">mut </span>mrb_state , arg2 : * <span class="kw-2">mut </span>mrb_parser_state) -&gt; * <span class="kw-2">mut </span>RProc ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_load_exec (mrb : * <span class="kw-2">mut </span>mrb_state , p : * <span class="kw-2">mut </span>mrb_parser_state , c : * <span class="kw-2">mut </span>mrbc_context) -&gt; mrb_value ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_load_string (mrb : * <span class="kw-2">mut </span>mrb_state , s : * <span class="kw">const </span>:: std :: os :: raw :: c_char) -&gt; mrb_value ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_load_nstring (mrb : * <span class="kw-2">mut </span>mrb_state , s : * <span class="kw">const </span>:: std :: os :: raw :: c_char , len : usize) -&gt; mrb_value ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_load_string_cxt (mrb : * <span class="kw-2">mut </span>mrb_state , s : * <span class="kw">const </span>:: std :: os :: raw :: c_char , cxt : * <span class="kw-2">mut </span>mrbc_context) -&gt; mrb_value ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_load_nstring_cxt (mrb : * <span class="kw-2">mut </span>mrb_state , s : * <span class="kw">const </span>:: std :: os :: raw :: c_char , len : usize , cxt : * <span class="kw-2">mut </span>mrbc_context) -&gt; mrb_value ; } # [repr (C)] # [derive (Debug , Copy , Clone)] <span class="kw">pub struct </span>mrb_data_type { <span class="kw">pub </span>struct_name : * <span class="kw">const </span>:: std :: os :: raw :: c_char , <span class="kw">pub </span>dfree : :: std :: option :: <span class="prelude-ty">Option </span>&lt; <span class="kw">unsafe extern </span><span class="string">"C" </span><span class="kw">fn </span>(mrb : * <span class="kw-2">mut </span>mrb_state , arg1 : * <span class="kw-2">mut </span>:: std :: os :: raw :: c_void) &gt; , } # [test] <span class="kw">fn </span>bindgen_test_layout_mrb_data_type () { <span class="kw">const </span>UNINIT : :: std :: mem :: MaybeUninit &lt; mrb_data_type &gt; = :: std :: mem :: MaybeUninit :: uninit () ; <span class="kw">let </span>ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: &lt; mrb_data_type &gt; () , <span class="number">16usize </span>, concat ! (<span class="string">"Size of: " </span>, stringify ! (mrb_data_type))) ; assert_eq ! (:: std :: mem :: align_of :: &lt; mrb_data_type &gt; () , <span class="number">8usize </span>, concat ! (<span class="string">"Alignment of " </span>, stringify ! (mrb_data_type))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . struct_name) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">0usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (mrb_data_type) , <span class="string">"::" </span>, stringify ! (struct_name))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . dfree) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">8usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (mrb_data_type) , <span class="string">"::" </span>, stringify ! (dfree))) ; } # [repr (C)] # [derive (Debug , Copy , Clone)] <span class="kw">pub struct </span>RData { <span class="kw">pub </span>c : * <span class="kw-2">mut </span>RClass , <span class="kw">pub </span>gcnext : * <span class="kw-2">mut </span>RBasic , <span class="kw">pub </span>_bitfield_align_1 : [u32 ; <span class="number">0</span>] , <span class="kw">pub </span>_bitfield_1 : __BindgenBitfieldUnit &lt; [u8 ; <span class="number">4usize</span>] &gt; , <span class="kw">pub </span>iv : * <span class="kw-2">mut </span>iv_tbl , <span class="kw">pub </span>type_ : * <span class="kw">const </span>mrb_data_type , <span class="kw">pub </span>data : * <span class="kw-2">mut </span>:: std :: os :: raw :: c_void , } # [test] <span class="kw">fn </span>bindgen_test_layout_RData () { <span class="kw">const </span>UNINIT : :: std :: mem :: MaybeUninit &lt; RData &gt; = :: std :: mem :: MaybeUninit :: uninit () ; <span class="kw">let </span>ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: &lt; RData &gt; () , <span class="number">48usize </span>, concat ! (<span class="string">"Size of: " </span>, stringify ! (RData))) ; assert_eq ! (:: std :: mem :: align_of :: &lt; RData &gt; () , <span class="number">8usize </span>, concat ! (<span class="string">"Alignment of " </span>, stringify ! (RData))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . c) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">0usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (RData) , <span class="string">"::" </span>, stringify ! (c))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . gcnext) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">8usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (RData) , <span class="string">"::" </span>, stringify ! (gcnext))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . iv) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">24usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (RData) , <span class="string">"::" </span>, stringify ! (iv))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . type_) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">32usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (RData) , <span class="string">"::" </span>, stringify ! (type_))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . data) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">40usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (RData) , <span class="string">"::" </span>, stringify ! (data))) ; } <span class="kw">impl </span>RData { # [inline] <span class="kw">pub fn </span>tt (&amp; <span class="self">self</span>) -&gt; mrb_vtype { <span class="kw">unsafe </span>{ :: std :: mem :: transmute (<span class="self">self </span>. _bitfield_1 . get (<span class="number">0usize </span>, <span class="number">8u8</span>) <span class="kw">as </span>u32) } } # [inline] <span class="kw">pub fn </span>set_tt (&amp; <span class="kw-2">mut </span><span class="self">self </span>, val : mrb_vtype) { <span class="kw">unsafe </span>{ <span class="kw">let </span>val : u32 = :: std :: mem :: transmute (val) ; <span class="self">self </span>. _bitfield_1 . set (<span class="number">0usize </span>, <span class="number">8u8 </span>, val <span class="kw">as </span>u64) } } # [inline] <span class="kw">pub fn </span>color (&amp; <span class="self">self</span>) -&gt; u32 { <span class="kw">unsafe </span>{ :: std :: mem :: transmute (<span class="self">self </span>. _bitfield_1 . get (<span class="number">8usize </span>, <span class="number">3u8</span>) <span class="kw">as </span>u32) } } # [inline] <span class="kw">pub fn </span>set_color (&amp; <span class="kw-2">mut </span><span class="self">self </span>, val : u32) { <span class="kw">unsafe </span>{ <span class="kw">let </span>val : u32 = :: std :: mem :: transmute (val) ; <span class="self">self </span>. _bitfield_1 . set (<span class="number">8usize </span>, <span class="number">3u8 </span>, val <span class="kw">as </span>u64) } } # [inline] <span class="kw">pub fn </span>flags (&amp; <span class="self">self</span>) -&gt; u32 { <span class="kw">unsafe </span>{ :: std :: mem :: transmute (<span class="self">self </span>. _bitfield_1 . get (<span class="number">11usize </span>, <span class="number">21u8</span>) <span class="kw">as </span>u32) } } # [inline] <span class="kw">pub fn </span>set_flags (&amp; <span class="kw-2">mut </span><span class="self">self </span>, val : u32) { <span class="kw">unsafe </span>{ <span class="kw">let </span>val : u32 = :: std :: mem :: transmute (val) ; <span class="self">self </span>. _bitfield_1 . set (<span class="number">11usize </span>, <span class="number">21u8 </span>, val <span class="kw">as </span>u64) } } # [inline] <span class="kw">pub fn </span>new_bitfield_1 (tt : mrb_vtype , color : u32 , flags : u32) -&gt; __BindgenBitfieldUnit &lt; [u8 ; <span class="number">4usize</span>] &gt; { <span class="kw">let </span><span class="kw-2">mut </span>__bindgen_bitfield_unit : __BindgenBitfieldUnit &lt; [u8 ; <span class="number">4usize</span>] &gt; = Default :: default () ; __bindgen_bitfield_unit . set (<span class="number">0usize </span>, <span class="number">8u8 </span>, { <span class="kw">let </span>tt : u32 = <span class="kw">unsafe </span>{ :: std :: mem :: transmute (tt) } ; tt <span class="kw">as </span>u64 }) ; __bindgen_bitfield_unit . set (<span class="number">8usize </span>, <span class="number">3u8 </span>, { <span class="kw">let </span>color : u32 = <span class="kw">unsafe </span>{ :: std :: mem :: transmute (color) } ; color <span class="kw">as </span>u64 }) ; __bindgen_bitfield_unit . set (<span class="number">11usize </span>, <span class="number">21u8 </span>, { <span class="kw">let </span>flags : u32 = <span class="kw">unsafe </span>{ :: std :: mem :: transmute (flags) } ; flags <span class="kw">as </span>u64 }) ; __bindgen_bitfield_unit } } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_data_object_alloc (mrb : * <span class="kw-2">mut </span>mrb_state , klass : * <span class="kw-2">mut </span>RClass , datap : * <span class="kw-2">mut </span>:: std :: os :: raw :: c_void , type_ : * <span class="kw">const </span>mrb_data_type) -&gt; * <span class="kw-2">mut </span>RData ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_data_check_type (mrb : * <span class="kw-2">mut </span>mrb_state , arg1 : mrb_value , arg2 : * <span class="kw">const </span>mrb_data_type) ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_data_get_ptr (mrb : * <span class="kw-2">mut </span>mrb_state , arg1 : mrb_value , arg2 : * <span class="kw">const </span>mrb_data_type) -&gt; * <span class="kw-2">mut </span>:: std :: os :: raw :: c_void ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_data_check_get_ptr (mrb : * <span class="kw-2">mut </span>mrb_state , arg1 : mrb_value , arg2 : * <span class="kw">const </span>mrb_data_type) -&gt; * <span class="kw-2">mut </span>:: std :: os :: raw :: c_void ; } # [repr (C)] # [derive (Copy , Clone)] <span class="kw">pub struct </span>mrb_pool_value { <span class="kw">pub </span>tt : u32 , <span class="kw">pub </span>u : mrb_pool_value__bindgen_ty_1 , } # [repr (C)] # [derive (Copy , Clone)] <span class="kw">pub union </span>mrb_pool_value__bindgen_ty_1 { <span class="kw">pub </span>str_ : * <span class="kw">const </span>:: std :: os :: raw :: c_char , <span class="kw">pub </span>i32_ : i32 , <span class="kw">pub </span>i64_ : i64 , <span class="kw">pub </span>f : mrb_float , } # [test] <span class="kw">fn </span>bindgen_test_layout_mrb_pool_value__bindgen_ty_1 () { <span class="kw">const </span>UNINIT : :: std :: mem :: MaybeUninit &lt; mrb_pool_value__bindgen_ty_1 &gt; = :: std :: mem :: MaybeUninit :: uninit () ; <span class="kw">let </span>ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: &lt; mrb_pool_value__bindgen_ty_1 &gt; () , <span class="number">8usize </span>, concat ! (<span class="string">"Size of: " </span>, stringify ! (mrb_pool_value__bindgen_ty_1))) ; assert_eq ! (:: std :: mem :: align_of :: &lt; mrb_pool_value__bindgen_ty_1 &gt; () , <span class="number">8usize </span>, concat ! (<span class="string">"Alignment of " </span>, stringify ! (mrb_pool_value__bindgen_ty_1))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . str_) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">0usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (mrb_pool_value__bindgen_ty_1) , <span class="string">"::" </span>, stringify ! (str_))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . i32_) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">0usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (mrb_pool_value__bindgen_ty_1) , <span class="string">"::" </span>, stringify ! (i32_))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . i64_) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">0usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (mrb_pool_value__bindgen_ty_1) , <span class="string">"::" </span>, stringify ! (i64_))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . f) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">0usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (mrb_pool_value__bindgen_ty_1) , <span class="string">"::" </span>, stringify ! (f))) ; } # [test] <span class="kw">fn </span>bindgen_test_layout_mrb_pool_value () { <span class="kw">const </span>UNINIT : :: std :: mem :: MaybeUninit &lt; mrb_pool_value &gt; = :: std :: mem :: MaybeUninit :: uninit () ; <span class="kw">let </span>ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: &lt; mrb_pool_value &gt; () , <span class="number">16usize </span>, concat ! (<span class="string">"Size of: " </span>, stringify ! (mrb_pool_value))) ; assert_eq ! (:: std :: mem :: align_of :: &lt; mrb_pool_value &gt; () , <span class="number">8usize </span>, concat ! (<span class="string">"Alignment of " </span>, stringify ! (mrb_pool_value))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . tt) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">0usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (mrb_pool_value) , <span class="string">"::" </span>, stringify ! (tt))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . u) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">8usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (mrb_pool_value) , <span class="string">"::" </span>, stringify ! (u))) ; } # [repr (u32)] # [derive (Debug , Copy , Clone , Hash , PartialEq , Eq)] <span class="kw">pub enum </span>mrb_catch_type { MRB_CATCH_RESCUE = <span class="number">0 </span>, MRB_CATCH_ENSURE = <span class="number">1 </span>, } # [repr (C)] # [derive (Debug , Copy , Clone)] <span class="kw">pub struct </span>mrb_irep_catch_handler { <span class="kw">pub </span>type_ : u8 , <span class="kw">pub </span>begin : [u8 ; <span class="number">4usize</span>] , <span class="kw">pub </span>end : [u8 ; <span class="number">4usize</span>] , <span class="kw">pub </span>target : [u8 ; <span class="number">4usize</span>] , } # [test] <span class="kw">fn </span>bindgen_test_layout_mrb_irep_catch_handler () { <span class="kw">const </span>UNINIT : :: std :: mem :: MaybeUninit &lt; mrb_irep_catch_handler &gt; = :: std :: mem :: MaybeUninit :: uninit () ; <span class="kw">let </span>ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: &lt; mrb_irep_catch_handler &gt; () , <span class="number">13usize </span>, concat ! (<span class="string">"Size of: " </span>, stringify ! (mrb_irep_catch_handler))) ; assert_eq ! (:: std :: mem :: align_of :: &lt; mrb_irep_catch_handler &gt; () , <span class="number">1usize </span>, concat ! (<span class="string">"Alignment of " </span>, stringify ! (mrb_irep_catch_handler))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . type_) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">0usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (mrb_irep_catch_handler) , <span class="string">"::" </span>, stringify ! (type_))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . begin) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">1usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (mrb_irep_catch_handler) , <span class="string">"::" </span>, stringify ! (begin))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . end) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">5usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (mrb_irep_catch_handler) , <span class="string">"::" </span>, stringify ! (end))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . target) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">9usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (mrb_irep_catch_handler) , <span class="string">"::" </span>, stringify ! (target))) ; } # [repr (C)] # [derive (Debug , Copy , Clone)] <span class="kw">pub struct </span>mrb_irep { <span class="kw">pub </span>nlocals : u16 , <span class="kw">pub </span>nregs : u16 , <span class="kw">pub </span>clen : u16 , <span class="kw">pub </span>flags : u8 , <span class="kw">pub </span>iseq : * <span class="kw">const </span>mrb_code , <span class="kw">pub </span>pool : * <span class="kw">const </span>mrb_pool_value , <span class="kw">pub </span>syms : * <span class="kw">const </span>mrb_sym , <span class="kw">pub </span>reps : * <span class="kw">const </span>* <span class="kw">const </span>mrb_irep , <span class="kw">pub </span>lv : * <span class="kw">const </span>mrb_sym , <span class="kw">pub </span>debug_info : * <span class="kw-2">mut </span>mrb_irep_debug_info , <span class="kw">pub </span>ilen : u32 , <span class="kw">pub </span>plen : u16 , <span class="kw">pub </span>slen : u16 , <span class="kw">pub </span>rlen : u16 , <span class="kw">pub </span>refcnt : u16 , } # [test] <span class="kw">fn </span>bindgen_test_layout_mrb_irep () { <span class="kw">const </span>UNINIT : :: std :: mem :: MaybeUninit &lt; mrb_irep &gt; = :: std :: mem :: MaybeUninit :: uninit () ; <span class="kw">let </span>ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: &lt; mrb_irep &gt; () , <span class="number">72usize </span>, concat ! (<span class="string">"Size of: " </span>, stringify ! (mrb_irep))) ; assert_eq ! (:: std :: mem :: align_of :: &lt; mrb_irep &gt; () , <span class="number">8usize </span>, concat ! (<span class="string">"Alignment of " </span>, stringify ! (mrb_irep))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . nlocals) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">0usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (mrb_irep) , <span class="string">"::" </span>, stringify ! (nlocals))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . nregs) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">2usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (mrb_irep) , <span class="string">"::" </span>, stringify ! (nregs))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . clen) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">4usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (mrb_irep) , <span class="string">"::" </span>, stringify ! (clen))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . flags) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">6usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (mrb_irep) , <span class="string">"::" </span>, stringify ! (flags))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . iseq) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">8usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (mrb_irep) , <span class="string">"::" </span>, stringify ! (iseq))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . pool) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">16usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (mrb_irep) , <span class="string">"::" </span>, stringify ! (pool))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . syms) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">24usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (mrb_irep) , <span class="string">"::" </span>, stringify ! (syms))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . reps) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">32usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (mrb_irep) , <span class="string">"::" </span>, stringify ! (reps))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . lv) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">40usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (mrb_irep) , <span class="string">"::" </span>, stringify ! (lv))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . debug_info) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">48usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (mrb_irep) , <span class="string">"::" </span>, stringify ! (debug_info))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . ilen) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">56usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (mrb_irep) , <span class="string">"::" </span>, stringify ! (ilen))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . plen) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">60usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (mrb_irep) , <span class="string">"::" </span>, stringify ! (plen))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . slen) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">62usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (mrb_irep) , <span class="string">"::" </span>, stringify ! (slen))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . rlen) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">64usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (mrb_irep) , <span class="string">"::" </span>, stringify ! (rlen))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . refcnt) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">66usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (mrb_irep) , <span class="string">"::" </span>, stringify ! (refcnt))) ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_add_irep (mrb : * <span class="kw-2">mut </span>mrb_state) -&gt; * <span class="kw-2">mut </span>mrb_irep ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_load_irep (arg1 : * <span class="kw-2">mut </span>mrb_state , arg2 : * <span class="kw">const </span>u8) -&gt; mrb_value ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_load_irep_buf (arg1 : * <span class="kw-2">mut </span>mrb_state , arg2 : * <span class="kw">const </span>:: std :: os :: raw :: c_void , arg3 : usize) -&gt; mrb_value ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_load_irep_cxt (arg1 : * <span class="kw-2">mut </span>mrb_state , arg2 : * <span class="kw">const </span>u8 , arg3 : * <span class="kw-2">mut </span>mrbc_context) -&gt; mrb_value ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_load_irep_buf_cxt (arg1 : * <span class="kw-2">mut </span>mrb_state , arg2 : * <span class="kw">const </span>:: std :: os :: raw :: c_void , arg3 : usize , arg4 : * <span class="kw-2">mut </span>mrbc_context) -&gt; mrb_value ; } # [repr (C)] # [derive (Debug , Copy , Clone)] <span class="kw">pub struct </span>mrb_insn_data { <span class="kw">pub </span>insn : u8 , <span class="kw">pub </span>a : u32 , <span class="kw">pub </span>b : u16 , <span class="kw">pub </span>c : u16 , <span class="kw">pub </span>addr : * <span class="kw">const </span>mrb_code , } # [test] <span class="kw">fn </span>bindgen_test_layout_mrb_insn_data () { <span class="kw">const </span>UNINIT : :: std :: mem :: MaybeUninit &lt; mrb_insn_data &gt; = :: std :: mem :: MaybeUninit :: uninit () ; <span class="kw">let </span>ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: &lt; mrb_insn_data &gt; () , <span class="number">24usize </span>, concat ! (<span class="string">"Size of: " </span>, stringify ! (mrb_insn_data))) ; assert_eq ! (:: std :: mem :: align_of :: &lt; mrb_insn_data &gt; () , <span class="number">8usize </span>, concat ! (<span class="string">"Alignment of " </span>, stringify ! (mrb_insn_data))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . insn) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">0usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (mrb_insn_data) , <span class="string">"::" </span>, stringify ! (insn))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . a) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">4usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (mrb_insn_data) , <span class="string">"::" </span>, stringify ! (a))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . b) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">8usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (mrb_insn_data) , <span class="string">"::" </span>, stringify ! (b))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . c) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">10usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (mrb_insn_data) , <span class="string">"::" </span>, stringify ! (c))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . addr) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">16usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (mrb_insn_data) , <span class="string">"::" </span>, stringify ! (addr))) ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_irep_incref (arg1 : * <span class="kw-2">mut </span>mrb_state , arg2 : * <span class="kw-2">mut </span>mrb_irep) ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_irep_decref (arg1 : * <span class="kw-2">mut </span>mrb_state , arg2 : * <span class="kw-2">mut </span>mrb_irep) ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_irep_cutref (arg1 : * <span class="kw-2">mut </span>mrb_state , arg2 : * <span class="kw-2">mut </span>mrb_irep) ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_read_irep (arg1 : * <span class="kw-2">mut </span>mrb_state , arg2 : * <span class="kw">const </span>u8) -&gt; * <span class="kw-2">mut </span>mrb_irep ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_read_irep_buf (arg1 : * <span class="kw-2">mut </span>mrb_state , arg2 : * <span class="kw">const </span>:: std :: os :: raw :: c_void , arg3 : usize) -&gt; * <span class="kw-2">mut </span>mrb_irep ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_sys_fail (mrb : * <span class="kw-2">mut </span>mrb_state , mesg : * <span class="kw">const </span>:: std :: os :: raw :: c_char) ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_exc_new_str (mrb : * <span class="kw-2">mut </span>mrb_state , c : * <span class="kw-2">mut </span>RClass , str_ : mrb_value) -&gt; mrb_value ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_make_exception (mrb : * <span class="kw-2">mut </span>mrb_state , argc : mrb_int , argv : * <span class="kw">const </span>mrb_value) -&gt; mrb_value ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_no_method_error (mrb : * <span class="kw-2">mut </span>mrb_state , id : mrb_sym , args : mrb_value , fmt : * <span class="kw">const </span>:: std :: os :: raw :: c_char , ...) ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_f_raise (arg1 : * <span class="kw-2">mut </span>mrb_state , arg2 : mrb_value) -&gt; mrb_value ; } <span class="kw">pub type </span>mrb_protect_error_func = :: std :: option :: <span class="prelude-ty">Option </span>&lt; <span class="kw">unsafe extern </span><span class="string">"C" </span><span class="kw">fn </span>(mrb : * <span class="kw-2">mut </span>mrb_state , userdata : * <span class="kw-2">mut </span>:: std :: os :: raw :: c_void) -&gt; mrb_value &gt; ; <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_protect_error (mrb : * <span class="kw-2">mut </span>mrb_state , body : mrb_protect_error_func , userdata : * <span class="kw-2">mut </span>:: std :: os :: raw :: c_void , error : * <span class="kw-2">mut </span>mrb_bool) -&gt; mrb_value ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_protect (mrb : * <span class="kw-2">mut </span>mrb_state , body : mrb_func_t , data : mrb_value , state : * <span class="kw-2">mut </span>mrb_bool) -&gt; mrb_value ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_ensure (mrb : * <span class="kw-2">mut </span>mrb_state , body : mrb_func_t , b_data : mrb_value , ensure : mrb_func_t , e_data : mrb_value) -&gt; mrb_value ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_rescue (mrb : * <span class="kw-2">mut </span>mrb_state , body : mrb_func_t , b_data : mrb_value , rescue : mrb_func_t , r_data : mrb_value) -&gt; mrb_value ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_rescue_exceptions (mrb : * <span class="kw-2">mut </span>mrb_state , body : mrb_func_t , b_data : mrb_value , rescue : mrb_func_t , r_data : mrb_value , len : mrb_int , classes : * <span class="kw-2">mut </span>* <span class="kw-2">mut </span>RClass) -&gt; mrb_value ; } # [repr (C)] # [derive (Copy , Clone)] <span class="kw">pub struct </span>RHash { <span class="kw">pub </span>c : * <span class="kw-2">mut </span>RClass , <span class="kw">pub </span>gcnext : * <span class="kw-2">mut </span>RBasic , <span class="kw">pub </span>_bitfield_align_1 : [u32 ; <span class="number">0</span>] , <span class="kw">pub </span>_bitfield_1 : __BindgenBitfieldUnit &lt; [u8 ; <span class="number">4usize</span>] &gt; , <span class="kw">pub </span>size : u32 , <span class="kw">pub </span>iv : * <span class="kw-2">mut </span>iv_tbl , <span class="kw">pub </span>ea_capa : u32 , <span class="kw">pub </span>ea_n_used : u32 , <span class="kw">pub </span>hsh : RHash__bindgen_ty_1 , } # [repr (C)] # [derive (Copy , Clone)] <span class="kw">pub union </span>RHash__bindgen_ty_1 { <span class="kw">pub </span>ea : * <span class="kw-2">mut </span>hash_entry , <span class="kw">pub </span>ht : * <span class="kw-2">mut </span>hash_table , } # [test] <span class="kw">fn </span>bindgen_test_layout_RHash__bindgen_ty_1 () { <span class="kw">const </span>UNINIT : :: std :: mem :: MaybeUninit &lt; RHash__bindgen_ty_1 &gt; = :: std :: mem :: MaybeUninit :: uninit () ; <span class="kw">let </span>ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: &lt; RHash__bindgen_ty_1 &gt; () , <span class="number">8usize </span>, concat ! (<span class="string">"Size of: " </span>, stringify ! (RHash__bindgen_ty_1))) ; assert_eq ! (:: std :: mem :: align_of :: &lt; RHash__bindgen_ty_1 &gt; () , <span class="number">8usize </span>, concat ! (<span class="string">"Alignment of " </span>, stringify ! (RHash__bindgen_ty_1))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . ea) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">0usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (RHash__bindgen_ty_1) , <span class="string">"::" </span>, stringify ! (ea))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . ht) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">0usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (RHash__bindgen_ty_1) , <span class="string">"::" </span>, stringify ! (ht))) ; } # [test] <span class="kw">fn </span>bindgen_test_layout_RHash () { <span class="kw">const </span>UNINIT : :: std :: mem :: MaybeUninit &lt; RHash &gt; = :: std :: mem :: MaybeUninit :: uninit () ; <span class="kw">let </span>ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: &lt; RHash &gt; () , <span class="number">48usize </span>, concat ! (<span class="string">"Size of: " </span>, stringify ! (RHash))) ; assert_eq ! (:: std :: mem :: align_of :: &lt; RHash &gt; () , <span class="number">8usize </span>, concat ! (<span class="string">"Alignment of " </span>, stringify ! (RHash))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . c) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">0usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (RHash) , <span class="string">"::" </span>, stringify ! (c))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . gcnext) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">8usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (RHash) , <span class="string">"::" </span>, stringify ! (gcnext))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . size) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">20usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (RHash) , <span class="string">"::" </span>, stringify ! (size))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . iv) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">24usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (RHash) , <span class="string">"::" </span>, stringify ! (iv))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . ea_capa) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">32usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (RHash) , <span class="string">"::" </span>, stringify ! (ea_capa))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . ea_n_used) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">36usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (RHash) , <span class="string">"::" </span>, stringify ! (ea_n_used))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . hsh) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">40usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (RHash) , <span class="string">"::" </span>, stringify ! (hsh))) ; } <span class="kw">impl </span>RHash { # [inline] <span class="kw">pub fn </span>tt (&amp; <span class="self">self</span>) -&gt; mrb_vtype { <span class="kw">unsafe </span>{ :: std :: mem :: transmute (<span class="self">self </span>. _bitfield_1 . get (<span class="number">0usize </span>, <span class="number">8u8</span>) <span class="kw">as </span>u32) } } # [inline] <span class="kw">pub fn </span>set_tt (&amp; <span class="kw-2">mut </span><span class="self">self </span>, val : mrb_vtype) { <span class="kw">unsafe </span>{ <span class="kw">let </span>val : u32 = :: std :: mem :: transmute (val) ; <span class="self">self </span>. _bitfield_1 . set (<span class="number">0usize </span>, <span class="number">8u8 </span>, val <span class="kw">as </span>u64) } } # [inline] <span class="kw">pub fn </span>color (&amp; <span class="self">self</span>) -&gt; u32 { <span class="kw">unsafe </span>{ :: std :: mem :: transmute (<span class="self">self </span>. _bitfield_1 . get (<span class="number">8usize </span>, <span class="number">3u8</span>) <span class="kw">as </span>u32) } } # [inline] <span class="kw">pub fn </span>set_color (&amp; <span class="kw-2">mut </span><span class="self">self </span>, val : u32) { <span class="kw">unsafe </span>{ <span class="kw">let </span>val : u32 = :: std :: mem :: transmute (val) ; <span class="self">self </span>. _bitfield_1 . set (<span class="number">8usize </span>, <span class="number">3u8 </span>, val <span class="kw">as </span>u64) } } # [inline] <span class="kw">pub fn </span>flags (&amp; <span class="self">self</span>) -&gt; u32 { <span class="kw">unsafe </span>{ :: std :: mem :: transmute (<span class="self">self </span>. _bitfield_1 . get (<span class="number">11usize </span>, <span class="number">21u8</span>) <span class="kw">as </span>u32) } } # [inline] <span class="kw">pub fn </span>set_flags (&amp; <span class="kw-2">mut </span><span class="self">self </span>, val : u32) { <span class="kw">unsafe </span>{ <span class="kw">let </span>val : u32 = :: std :: mem :: transmute (val) ; <span class="self">self </span>. _bitfield_1 . set (<span class="number">11usize </span>, <span class="number">21u8 </span>, val <span class="kw">as </span>u64) } } # [inline] <span class="kw">pub fn </span>new_bitfield_1 (tt : mrb_vtype , color : u32 , flags : u32) -&gt; __BindgenBitfieldUnit &lt; [u8 ; <span class="number">4usize</span>] &gt; { <span class="kw">let </span><span class="kw-2">mut </span>__bindgen_bitfield_unit : __BindgenBitfieldUnit &lt; [u8 ; <span class="number">4usize</span>] &gt; = Default :: default () ; __bindgen_bitfield_unit . set (<span class="number">0usize </span>, <span class="number">8u8 </span>, { <span class="kw">let </span>tt : u32 = <span class="kw">unsafe </span>{ :: std :: mem :: transmute (tt) } ; tt <span class="kw">as </span>u64 }) ; __bindgen_bitfield_unit . set (<span class="number">8usize </span>, <span class="number">3u8 </span>, { <span class="kw">let </span>color : u32 = <span class="kw">unsafe </span>{ :: std :: mem :: transmute (color) } ; color <span class="kw">as </span>u64 }) ; __bindgen_bitfield_unit . set (<span class="number">11usize </span>, <span class="number">21u8 </span>, { <span class="kw">let </span>flags : u32 = <span class="kw">unsafe </span>{ :: std :: mem :: transmute (flags) } ; flags <span class="kw">as </span>u64 }) ; __bindgen_bitfield_unit } } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_hash_new_capa (mrb : * <span class="kw-2">mut </span>mrb_state , capa : mrb_int) -&gt; mrb_value ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_hash_new (mrb : * <span class="kw-2">mut </span>mrb_state) -&gt; mrb_value ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_hash_set (mrb : * <span class="kw-2">mut </span>mrb_state , hash : mrb_value , key : mrb_value , val : mrb_value) ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_hash_get (mrb : * <span class="kw-2">mut </span>mrb_state , hash : mrb_value , key : mrb_value) -&gt; mrb_value ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_hash_fetch (mrb : * <span class="kw-2">mut </span>mrb_state , hash : mrb_value , key : mrb_value , def : mrb_value) -&gt; mrb_value ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_hash_delete_key (mrb : * <span class="kw-2">mut </span>mrb_state , hash : mrb_value , key : mrb_value) -&gt; mrb_value ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_hash_keys (mrb : * <span class="kw-2">mut </span>mrb_state , hash : mrb_value) -&gt; mrb_value ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_hash_key_p (mrb : * <span class="kw-2">mut </span>mrb_state , hash : mrb_value , key : mrb_value) -&gt; mrb_bool ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_hash_empty_p (mrb : * <span class="kw-2">mut </span>mrb_state , self_ : mrb_value) -&gt; mrb_bool ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_hash_values (mrb : * <span class="kw-2">mut </span>mrb_state , hash : mrb_value) -&gt; mrb_value ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_hash_clear (mrb : * <span class="kw-2">mut </span>mrb_state , hash : mrb_value) -&gt; mrb_value ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_hash_size (mrb : * <span class="kw-2">mut </span>mrb_state , hash : mrb_value) -&gt; mrb_int ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_hash_dup (mrb : * <span class="kw-2">mut </span>mrb_state , hash : mrb_value) -&gt; mrb_value ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_hash_merge (mrb : * <span class="kw-2">mut </span>mrb_state , hash1 : mrb_value , hash2 : mrb_value) ; } <span class="kw">pub type </span>mrb_hash_foreach_func = :: std :: option :: <span class="prelude-ty">Option </span>&lt; <span class="kw">unsafe extern </span><span class="string">"C" </span><span class="kw">fn </span>(mrb : * <span class="kw-2">mut </span>mrb_state , key : mrb_value , val : mrb_value , data : * <span class="kw-2">mut </span>:: std :: os :: raw :: c_void) -&gt; :: std :: os :: raw :: c_int &gt; ; <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_hash_foreach (mrb : * <span class="kw-2">mut </span>mrb_state , hash : * <span class="kw-2">mut </span>RHash , func : mrb_hash_foreach_func , p : * <span class="kw-2">mut </span>:: std :: os :: raw :: c_void) ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_num_add (mrb : * <span class="kw-2">mut </span>mrb_state , x : mrb_value , y : mrb_value) -&gt; mrb_value ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_num_sub (mrb : * <span class="kw-2">mut </span>mrb_state , x : mrb_value , y : mrb_value) -&gt; mrb_value ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_num_mul (mrb : * <span class="kw-2">mut </span>mrb_state , x : mrb_value , y : mrb_value) -&gt; mrb_value ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_integer_to_str (mrb : * <span class="kw-2">mut </span>mrb_state , x : mrb_value , base : mrb_int) -&gt; mrb_value ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_int_to_cstr (buf : * <span class="kw-2">mut </span>:: std :: os :: raw :: c_char , len : usize , n : mrb_int , base : mrb_int) -&gt; * <span class="kw-2">mut </span>:: std :: os :: raw :: c_char ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_float_to_integer (mrb : * <span class="kw-2">mut </span>mrb_state , val : mrb_value) -&gt; mrb_value ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_div_float (x : mrb_float , y : mrb_float) -&gt; mrb_float ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_float_to_str (mrb : * <span class="kw-2">mut </span>mrb_state , x : mrb_value , fmt : * <span class="kw">const </span>:: std :: os :: raw :: c_char) -&gt; mrb_value ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_format_float (f : mrb_float , buf : * <span class="kw-2">mut </span>:: std :: os :: raw :: c_char , buf_size : usize , fmt : :: std :: os :: raw :: c_char , prec : :: std :: os :: raw :: c_int , sign : :: std :: os :: raw :: c_char) -&gt; :: std :: os :: raw :: c_int ; } # [repr (u32)] # [derive (Debug , Copy , Clone , Hash , PartialEq , Eq)] <span class="kw">pub enum </span>mrb_insn { OP_NOP = <span class="number">0 </span>, OP_MOVE = <span class="number">1 </span>, OP_LOADL = <span class="number">2 </span>, OP_LOADI = <span class="number">3 </span>, OP_LOADINEG = <span class="number">4 </span>, OP_LOADI__1 = <span class="number">5 </span>, OP_LOADI_0 = <span class="number">6 </span>, OP_LOADI_1 = <span class="number">7 </span>, OP_LOADI_2 = <span class="number">8 </span>, OP_LOADI_3 = <span class="number">9 </span>, OP_LOADI_4 = <span class="number">10 </span>, OP_LOADI_5 = <span class="number">11 </span>, OP_LOADI_6 = <span class="number">12 </span>, OP_LOADI_7 = <span class="number">13 </span>, OP_LOADI16 = <span class="number">14 </span>, OP_LOADI32 = <span class="number">15 </span>, OP_LOADSYM = <span class="number">16 </span>, OP_LOADNIL = <span class="number">17 </span>, OP_LOADSELF = <span class="number">18 </span>, OP_LOADT = <span class="number">19 </span>, OP_LOADF = <span class="number">20 </span>, OP_GETGV = <span class="number">21 </span>, OP_SETGV = <span class="number">22 </span>, OP_GETSV = <span class="number">23 </span>, OP_SETSV = <span class="number">24 </span>, OP_GETIV = <span class="number">25 </span>, OP_SETIV = <span class="number">26 </span>, OP_GETCV = <span class="number">27 </span>, OP_SETCV = <span class="number">28 </span>, OP_GETCONST = <span class="number">29 </span>, OP_SETCONST = <span class="number">30 </span>, OP_GETMCNST = <span class="number">31 </span>, OP_SETMCNST = <span class="number">32 </span>, OP_GETUPVAR = <span class="number">33 </span>, OP_SETUPVAR = <span class="number">34 </span>, OP_GETIDX = <span class="number">35 </span>, OP_SETIDX = <span class="number">36 </span>, OP_JMP = <span class="number">37 </span>, OP_JMPIF = <span class="number">38 </span>, OP_JMPNOT = <span class="number">39 </span>, OP_JMPNIL = <span class="number">40 </span>, OP_JMPUW = <span class="number">41 </span>, OP_EXCEPT = <span class="number">42 </span>, OP_RESCUE = <span class="number">43 </span>, OP_RAISEIF = <span class="number">44 </span>, OP_SSEND = <span class="number">45 </span>, OP_SSENDB = <span class="number">46 </span>, OP_SEND = <span class="number">47 </span>, OP_SENDB = <span class="number">48 </span>, OP_CALL = <span class="number">49 </span>, OP_SUPER = <span class="number">50 </span>, OP_ARGARY = <span class="number">51 </span>, OP_ENTER = <span class="number">52 </span>, OP_KEY_P = <span class="number">53 </span>, OP_KEYEND = <span class="number">54 </span>, OP_KARG = <span class="number">55 </span>, OP_RETURN = <span class="number">56 </span>, OP_RETURN_BLK = <span class="number">57 </span>, OP_BREAK = <span class="number">58 </span>, OP_BLKPUSH = <span class="number">59 </span>, OP_ADD = <span class="number">60 </span>, OP_ADDI = <span class="number">61 </span>, OP_SUB = <span class="number">62 </span>, OP_SUBI = <span class="number">63 </span>, OP_MUL = <span class="number">64 </span>, OP_DIV = <span class="number">65 </span>, OP_EQ = <span class="number">66 </span>, OP_LT = <span class="number">67 </span>, OP_LE = <span class="number">68 </span>, OP_GT = <span class="number">69 </span>, OP_GE = <span class="number">70 </span>, OP_ARRAY = <span class="number">71 </span>, OP_ARRAY2 = <span class="number">72 </span>, OP_ARYCAT = <span class="number">73 </span>, OP_ARYPUSH = <span class="number">74 </span>, OP_ARYSPLAT = <span class="number">75 </span>, OP_AREF = <span class="number">76 </span>, OP_ASET = <span class="number">77 </span>, OP_APOST = <span class="number">78 </span>, OP_INTERN = <span class="number">79 </span>, OP_SYMBOL = <span class="number">80 </span>, OP_STRING = <span class="number">81 </span>, OP_STRCAT = <span class="number">82 </span>, OP_HASH = <span class="number">83 </span>, OP_HASHADD = <span class="number">84 </span>, OP_HASHCAT = <span class="number">85 </span>, OP_LAMBDA = <span class="number">86 </span>, OP_BLOCK = <span class="number">87 </span>, OP_METHOD = <span class="number">88 </span>, OP_RANGE_INC = <span class="number">89 </span>, OP_RANGE_EXC = <span class="number">90 </span>, OP_OCLASS = <span class="number">91 </span>, OP_CLASS = <span class="number">92 </span>, OP_MODULE = <span class="number">93 </span>, OP_EXEC = <span class="number">94 </span>, OP_DEF = <span class="number">95 </span>, OP_ALIAS = <span class="number">96 </span>, OP_UNDEF = <span class="number">97 </span>, OP_SCLASS = <span class="number">98 </span>, OP_TCLASS = <span class="number">99 </span>, OP_DEBUG = <span class="number">100 </span>, OP_ERR = <span class="number">101 </span>, OP_EXT1 = <span class="number">102 </span>, OP_EXT2 = <span class="number">103 </span>, OP_EXT3 = <span class="number">104 </span>, OP_STOP = <span class="number">105 </span>, } # [repr (C)] # [derive (Debug , Copy , Clone)] <span class="kw">pub struct </span>REnv { <span class="kw">pub </span>c : * <span class="kw-2">mut </span>RClass , <span class="kw">pub </span>gcnext : * <span class="kw-2">mut </span>RBasic , <span class="kw">pub </span>_bitfield_align_1 : [u32 ; <span class="number">0</span>] , <span class="kw">pub </span>_bitfield_1 : __BindgenBitfieldUnit &lt; [u8 ; <span class="number">4usize</span>] &gt; , <span class="kw">pub </span>stack : * <span class="kw-2">mut </span>mrb_value , <span class="kw">pub </span>cxt : * <span class="kw-2">mut </span>mrb_context , <span class="kw">pub </span>mid : mrb_sym , } # [test] <span class="kw">fn </span>bindgen_test_layout_REnv () { <span class="kw">const </span>UNINIT : :: std :: mem :: MaybeUninit &lt; REnv &gt; = :: std :: mem :: MaybeUninit :: uninit () ; <span class="kw">let </span>ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: &lt; REnv &gt; () , <span class="number">48usize </span>, concat ! (<span class="string">"Size of: " </span>, stringify ! (REnv))) ; assert_eq ! (:: std :: mem :: align_of :: &lt; REnv &gt; () , <span class="number">8usize </span>, concat ! (<span class="string">"Alignment of " </span>, stringify ! (REnv))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . c) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">0usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (REnv) , <span class="string">"::" </span>, stringify ! (c))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . gcnext) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">8usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (REnv) , <span class="string">"::" </span>, stringify ! (gcnext))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . stack) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">24usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (REnv) , <span class="string">"::" </span>, stringify ! (stack))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . cxt) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">32usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (REnv) , <span class="string">"::" </span>, stringify ! (cxt))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . mid) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">40usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (REnv) , <span class="string">"::" </span>, stringify ! (mid))) ; } <span class="kw">impl </span>REnv { # [inline] <span class="kw">pub fn </span>tt (&amp; <span class="self">self</span>) -&gt; mrb_vtype { <span class="kw">unsafe </span>{ :: std :: mem :: transmute (<span class="self">self </span>. _bitfield_1 . get (<span class="number">0usize </span>, <span class="number">8u8</span>) <span class="kw">as </span>u32) } } # [inline] <span class="kw">pub fn </span>set_tt (&amp; <span class="kw-2">mut </span><span class="self">self </span>, val : mrb_vtype) { <span class="kw">unsafe </span>{ <span class="kw">let </span>val : u32 = :: std :: mem :: transmute (val) ; <span class="self">self </span>. _bitfield_1 . set (<span class="number">0usize </span>, <span class="number">8u8 </span>, val <span class="kw">as </span>u64) } } # [inline] <span class="kw">pub fn </span>color (&amp; <span class="self">self</span>) -&gt; u32 { <span class="kw">unsafe </span>{ :: std :: mem :: transmute (<span class="self">self </span>. _bitfield_1 . get (<span class="number">8usize </span>, <span class="number">3u8</span>) <span class="kw">as </span>u32) } } # [inline] <span class="kw">pub fn </span>set_color (&amp; <span class="kw-2">mut </span><span class="self">self </span>, val : u32) { <span class="kw">unsafe </span>{ <span class="kw">let </span>val : u32 = :: std :: mem :: transmute (val) ; <span class="self">self </span>. _bitfield_1 . set (<span class="number">8usize </span>, <span class="number">3u8 </span>, val <span class="kw">as </span>u64) } } # [inline] <span class="kw">pub fn </span>flags (&amp; <span class="self">self</span>) -&gt; u32 { <span class="kw">unsafe </span>{ :: std :: mem :: transmute (<span class="self">self </span>. _bitfield_1 . get (<span class="number">11usize </span>, <span class="number">21u8</span>) <span class="kw">as </span>u32) } } # [inline] <span class="kw">pub fn </span>set_flags (&amp; <span class="kw-2">mut </span><span class="self">self </span>, val : u32) { <span class="kw">unsafe </span>{ <span class="kw">let </span>val : u32 = :: std :: mem :: transmute (val) ; <span class="self">self </span>. _bitfield_1 . set (<span class="number">11usize </span>, <span class="number">21u8 </span>, val <span class="kw">as </span>u64) } } # [inline] <span class="kw">pub fn </span>new_bitfield_1 (tt : mrb_vtype , color : u32 , flags : u32) -&gt; __BindgenBitfieldUnit &lt; [u8 ; <span class="number">4usize</span>] &gt; { <span class="kw">let </span><span class="kw-2">mut </span>__bindgen_bitfield_unit : __BindgenBitfieldUnit &lt; [u8 ; <span class="number">4usize</span>] &gt; = Default :: default () ; __bindgen_bitfield_unit . set (<span class="number">0usize </span>, <span class="number">8u8 </span>, { <span class="kw">let </span>tt : u32 = <span class="kw">unsafe </span>{ :: std :: mem :: transmute (tt) } ; tt <span class="kw">as </span>u64 }) ; __bindgen_bitfield_unit . set (<span class="number">8usize </span>, <span class="number">3u8 </span>, { <span class="kw">let </span>color : u32 = <span class="kw">unsafe </span>{ :: std :: mem :: transmute (color) } ; color <span class="kw">as </span>u64 }) ; __bindgen_bitfield_unit . set (<span class="number">11usize </span>, <span class="number">21u8 </span>, { <span class="kw">let </span>flags : u32 = <span class="kw">unsafe </span>{ :: std :: mem :: transmute (flags) } ; flags <span class="kw">as </span>u64 }) ; __bindgen_bitfield_unit } } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_env_unshare (arg1 : * <span class="kw-2">mut </span>mrb_state , arg2 : * <span class="kw-2">mut </span>REnv , noraise : mrb_bool) -&gt; mrb_bool ; } # [repr (C)] # [derive (Copy , Clone)] <span class="kw">pub struct </span>RProc { <span class="kw">pub </span>c : * <span class="kw-2">mut </span>RClass , <span class="kw">pub </span>gcnext : * <span class="kw-2">mut </span>RBasic , <span class="kw">pub </span>_bitfield_align_1 : [u32 ; <span class="number">0</span>] , <span class="kw">pub </span>_bitfield_1 : __BindgenBitfieldUnit &lt; [u8 ; <span class="number">4usize</span>] &gt; , <span class="kw">pub </span>body : RProc__bindgen_ty_1 , <span class="kw">pub </span>upper : * <span class="kw">const </span>RProc , <span class="kw">pub </span>e : RProc__bindgen_ty_2 , } # [repr (C)] # [derive (Copy , Clone)] <span class="kw">pub union </span>RProc__bindgen_ty_1 { <span class="kw">pub </span>irep : * <span class="kw">const </span>mrb_irep , <span class="kw">pub </span>func : mrb_func_t , } # [test] <span class="kw">fn </span>bindgen_test_layout_RProc__bindgen_ty_1 () { <span class="kw">const </span>UNINIT : :: std :: mem :: MaybeUninit &lt; RProc__bindgen_ty_1 &gt; = :: std :: mem :: MaybeUninit :: uninit () ; <span class="kw">let </span>ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: &lt; RProc__bindgen_ty_1 &gt; () , <span class="number">8usize </span>, concat ! (<span class="string">"Size of: " </span>, stringify ! (RProc__bindgen_ty_1))) ; assert_eq ! (:: std :: mem :: align_of :: &lt; RProc__bindgen_ty_1 &gt; () , <span class="number">8usize </span>, concat ! (<span class="string">"Alignment of " </span>, stringify ! (RProc__bindgen_ty_1))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . irep) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">0usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (RProc__bindgen_ty_1) , <span class="string">"::" </span>, stringify ! (irep))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . func) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">0usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (RProc__bindgen_ty_1) , <span class="string">"::" </span>, stringify ! (func))) ; } # [repr (C)] # [derive (Copy , Clone)] <span class="kw">pub union </span>RProc__bindgen_ty_2 { <span class="kw">pub </span>target_class : * <span class="kw-2">mut </span>RClass , <span class="kw">pub </span>env : * <span class="kw-2">mut </span>REnv , } # [test] <span class="kw">fn </span>bindgen_test_layout_RProc__bindgen_ty_2 () { <span class="kw">const </span>UNINIT : :: std :: mem :: MaybeUninit &lt; RProc__bindgen_ty_2 &gt; = :: std :: mem :: MaybeUninit :: uninit () ; <span class="kw">let </span>ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: &lt; RProc__bindgen_ty_2 &gt; () , <span class="number">8usize </span>, concat ! (<span class="string">"Size of: " </span>, stringify ! (RProc__bindgen_ty_2))) ; assert_eq ! (:: std :: mem :: align_of :: &lt; RProc__bindgen_ty_2 &gt; () , <span class="number">8usize </span>, concat ! (<span class="string">"Alignment of " </span>, stringify ! (RProc__bindgen_ty_2))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . target_class) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">0usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (RProc__bindgen_ty_2) , <span class="string">"::" </span>, stringify ! (target_class))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . env) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">0usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (RProc__bindgen_ty_2) , <span class="string">"::" </span>, stringify ! (env))) ; } # [test] <span class="kw">fn </span>bindgen_test_layout_RProc () { <span class="kw">const </span>UNINIT : :: std :: mem :: MaybeUninit &lt; RProc &gt; = :: std :: mem :: MaybeUninit :: uninit () ; <span class="kw">let </span>ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: &lt; RProc &gt; () , <span class="number">48usize </span>, concat ! (<span class="string">"Size of: " </span>, stringify ! (RProc))) ; assert_eq ! (:: std :: mem :: align_of :: &lt; RProc &gt; () , <span class="number">8usize </span>, concat ! (<span class="string">"Alignment of " </span>, stringify ! (RProc))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . c) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">0usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (RProc) , <span class="string">"::" </span>, stringify ! (c))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . gcnext) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">8usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (RProc) , <span class="string">"::" </span>, stringify ! (gcnext))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . body) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">24usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (RProc) , <span class="string">"::" </span>, stringify ! (body))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . upper) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">32usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (RProc) , <span class="string">"::" </span>, stringify ! (upper))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . e) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">40usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (RProc) , <span class="string">"::" </span>, stringify ! (e))) ; } <span class="kw">impl </span>RProc { # [inline] <span class="kw">pub fn </span>tt (&amp; <span class="self">self</span>) -&gt; mrb_vtype { <span class="kw">unsafe </span>{ :: std :: mem :: transmute (<span class="self">self </span>. _bitfield_1 . get (<span class="number">0usize </span>, <span class="number">8u8</span>) <span class="kw">as </span>u32) } } # [inline] <span class="kw">pub fn </span>set_tt (&amp; <span class="kw-2">mut </span><span class="self">self </span>, val : mrb_vtype) { <span class="kw">unsafe </span>{ <span class="kw">let </span>val : u32 = :: std :: mem :: transmute (val) ; <span class="self">self </span>. _bitfield_1 . set (<span class="number">0usize </span>, <span class="number">8u8 </span>, val <span class="kw">as </span>u64) } } # [inline] <span class="kw">pub fn </span>color (&amp; <span class="self">self</span>) -&gt; u32 { <span class="kw">unsafe </span>{ :: std :: mem :: transmute (<span class="self">self </span>. _bitfield_1 . get (<span class="number">8usize </span>, <span class="number">3u8</span>) <span class="kw">as </span>u32) } } # [inline] <span class="kw">pub fn </span>set_color (&amp; <span class="kw-2">mut </span><span class="self">self </span>, val : u32) { <span class="kw">unsafe </span>{ <span class="kw">let </span>val : u32 = :: std :: mem :: transmute (val) ; <span class="self">self </span>. _bitfield_1 . set (<span class="number">8usize </span>, <span class="number">3u8 </span>, val <span class="kw">as </span>u64) } } # [inline] <span class="kw">pub fn </span>flags (&amp; <span class="self">self</span>) -&gt; u32 { <span class="kw">unsafe </span>{ :: std :: mem :: transmute (<span class="self">self </span>. _bitfield_1 . get (<span class="number">11usize </span>, <span class="number">21u8</span>) <span class="kw">as </span>u32) } } # [inline] <span class="kw">pub fn </span>set_flags (&amp; <span class="kw-2">mut </span><span class="self">self </span>, val : u32) { <span class="kw">unsafe </span>{ <span class="kw">let </span>val : u32 = :: std :: mem :: transmute (val) ; <span class="self">self </span>. _bitfield_1 . set (<span class="number">11usize </span>, <span class="number">21u8 </span>, val <span class="kw">as </span>u64) } } # [inline] <span class="kw">pub fn </span>new_bitfield_1 (tt : mrb_vtype , color : u32 , flags : u32) -&gt; __BindgenBitfieldUnit &lt; [u8 ; <span class="number">4usize</span>] &gt; { <span class="kw">let </span><span class="kw-2">mut </span>__bindgen_bitfield_unit : __BindgenBitfieldUnit &lt; [u8 ; <span class="number">4usize</span>] &gt; = Default :: default () ; __bindgen_bitfield_unit . set (<span class="number">0usize </span>, <span class="number">8u8 </span>, { <span class="kw">let </span>tt : u32 = <span class="kw">unsafe </span>{ :: std :: mem :: transmute (tt) } ; tt <span class="kw">as </span>u64 }) ; __bindgen_bitfield_unit . set (<span class="number">8usize </span>, <span class="number">3u8 </span>, { <span class="kw">let </span>color : u32 = <span class="kw">unsafe </span>{ :: std :: mem :: transmute (color) } ; color <span class="kw">as </span>u64 }) ; __bindgen_bitfield_unit . set (<span class="number">11usize </span>, <span class="number">21u8 </span>, { <span class="kw">let </span>flags : u32 = <span class="kw">unsafe </span>{ :: std :: mem :: transmute (flags) } ; flags <span class="kw">as </span>u64 }) ; __bindgen_bitfield_unit } } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_proc_new (arg1 : * <span class="kw-2">mut </span>mrb_state , arg2 : * <span class="kw">const </span>mrb_irep) -&gt; * <span class="kw-2">mut </span>RProc ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_proc_new_cfunc (arg1 : * <span class="kw-2">mut </span>mrb_state , arg2 : mrb_func_t) -&gt; * <span class="kw-2">mut </span>RProc ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_closure_new_cfunc (mrb : * <span class="kw-2">mut </span>mrb_state , func : mrb_func_t , nlocals : :: std :: os :: raw :: c_int) -&gt; * <span class="kw-2">mut </span>RProc ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_proc_new_cfunc_with_env (mrb : * <span class="kw-2">mut </span>mrb_state , func : mrb_func_t , argc : mrb_int , argv : * <span class="kw">const </span>mrb_value) -&gt; * <span class="kw-2">mut </span>RProc ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_proc_cfunc_env_get (mrb : * <span class="kw-2">mut </span>mrb_state , idx : mrb_int) -&gt; mrb_value ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_load_proc (mrb : * <span class="kw-2">mut </span>mrb_state , proc_ : * <span class="kw">const </span>RProc) -&gt; mrb_value ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_vm_ci_proc_set (ci : * <span class="kw-2">mut </span>mrb_callinfo , p : * <span class="kw">const </span>RProc) ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_vm_ci_target_class (ci : * <span class="kw">const </span>mrb_callinfo) -&gt; * <span class="kw-2">mut </span>RClass ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_vm_ci_target_class_set (ci : * <span class="kw-2">mut </span>mrb_callinfo , tc : * <span class="kw-2">mut </span>RClass) ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_vm_ci_env (ci : * <span class="kw">const </span>mrb_callinfo) -&gt; * <span class="kw-2">mut </span>REnv ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_vm_ci_env_set (ci : * <span class="kw-2">mut </span>mrb_callinfo , e : * <span class="kw-2">mut </span>REnv) ; } # [repr (C)] # [derive (Copy , Clone)] <span class="kw">pub struct </span>mrb_range_edges { <span class="kw">pub </span>beg : mrb_value , <span class="kw">pub </span>end : mrb_value , } # [test] <span class="kw">fn </span>bindgen_test_layout_mrb_range_edges () { <span class="kw">const </span>UNINIT : :: std :: mem :: MaybeUninit &lt; mrb_range_edges &gt; = :: std :: mem :: MaybeUninit :: uninit () ; <span class="kw">let </span>ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: &lt; mrb_range_edges &gt; () , <span class="number">32usize </span>, concat ! (<span class="string">"Size of: " </span>, stringify ! (mrb_range_edges))) ; assert_eq ! (:: std :: mem :: align_of :: &lt; mrb_range_edges &gt; () , <span class="number">8usize </span>, concat ! (<span class="string">"Alignment of " </span>, stringify ! (mrb_range_edges))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . beg) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">0usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (mrb_range_edges) , <span class="string">"::" </span>, stringify ! (beg))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . end) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">16usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (mrb_range_edges) , <span class="string">"::" </span>, stringify ! (end))) ; } # [repr (C)] # [derive (Debug , Copy , Clone)] <span class="kw">pub struct </span>RRange { <span class="kw">pub </span>c : * <span class="kw-2">mut </span>RClass , <span class="kw">pub </span>gcnext : * <span class="kw-2">mut </span>RBasic , <span class="kw">pub </span>_bitfield_align_1 : [u32 ; <span class="number">0</span>] , <span class="kw">pub </span>_bitfield_1 : __BindgenBitfieldUnit &lt; [u8 ; <span class="number">4usize</span>] &gt; , <span class="kw">pub </span>edges : * <span class="kw-2">mut </span>mrb_range_edges , <span class="kw">pub </span>excl : mrb_bool , } # [test] <span class="kw">fn </span>bindgen_test_layout_RRange () { <span class="kw">const </span>UNINIT : :: std :: mem :: MaybeUninit &lt; RRange &gt; = :: std :: mem :: MaybeUninit :: uninit () ; <span class="kw">let </span>ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: &lt; RRange &gt; () , <span class="number">40usize </span>, concat ! (<span class="string">"Size of: " </span>, stringify ! (RRange))) ; assert_eq ! (:: std :: mem :: align_of :: &lt; RRange &gt; () , <span class="number">8usize </span>, concat ! (<span class="string">"Alignment of " </span>, stringify ! (RRange))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . c) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">0usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (RRange) , <span class="string">"::" </span>, stringify ! (c))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . gcnext) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">8usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (RRange) , <span class="string">"::" </span>, stringify ! (gcnext))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . edges) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">24usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (RRange) , <span class="string">"::" </span>, stringify ! (edges))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . excl) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">32usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (RRange) , <span class="string">"::" </span>, stringify ! (excl))) ; } <span class="kw">impl </span>RRange { # [inline] <span class="kw">pub fn </span>tt (&amp; <span class="self">self</span>) -&gt; mrb_vtype { <span class="kw">unsafe </span>{ :: std :: mem :: transmute (<span class="self">self </span>. _bitfield_1 . get (<span class="number">0usize </span>, <span class="number">8u8</span>) <span class="kw">as </span>u32) } } # [inline] <span class="kw">pub fn </span>set_tt (&amp; <span class="kw-2">mut </span><span class="self">self </span>, val : mrb_vtype) { <span class="kw">unsafe </span>{ <span class="kw">let </span>val : u32 = :: std :: mem :: transmute (val) ; <span class="self">self </span>. _bitfield_1 . set (<span class="number">0usize </span>, <span class="number">8u8 </span>, val <span class="kw">as </span>u64) } } # [inline] <span class="kw">pub fn </span>color (&amp; <span class="self">self</span>) -&gt; u32 { <span class="kw">unsafe </span>{ :: std :: mem :: transmute (<span class="self">self </span>. _bitfield_1 . get (<span class="number">8usize </span>, <span class="number">3u8</span>) <span class="kw">as </span>u32) } } # [inline] <span class="kw">pub fn </span>set_color (&amp; <span class="kw-2">mut </span><span class="self">self </span>, val : u32) { <span class="kw">unsafe </span>{ <span class="kw">let </span>val : u32 = :: std :: mem :: transmute (val) ; <span class="self">self </span>. _bitfield_1 . set (<span class="number">8usize </span>, <span class="number">3u8 </span>, val <span class="kw">as </span>u64) } } # [inline] <span class="kw">pub fn </span>flags (&amp; <span class="self">self</span>) -&gt; u32 { <span class="kw">unsafe </span>{ :: std :: mem :: transmute (<span class="self">self </span>. _bitfield_1 . get (<span class="number">11usize </span>, <span class="number">21u8</span>) <span class="kw">as </span>u32) } } # [inline] <span class="kw">pub fn </span>set_flags (&amp; <span class="kw-2">mut </span><span class="self">self </span>, val : u32) { <span class="kw">unsafe </span>{ <span class="kw">let </span>val : u32 = :: std :: mem :: transmute (val) ; <span class="self">self </span>. _bitfield_1 . set (<span class="number">11usize </span>, <span class="number">21u8 </span>, val <span class="kw">as </span>u64) } } # [inline] <span class="kw">pub fn </span>new_bitfield_1 (tt : mrb_vtype , color : u32 , flags : u32) -&gt; __BindgenBitfieldUnit &lt; [u8 ; <span class="number">4usize</span>] &gt; { <span class="kw">let </span><span class="kw-2">mut </span>__bindgen_bitfield_unit : __BindgenBitfieldUnit &lt; [u8 ; <span class="number">4usize</span>] &gt; = Default :: default () ; __bindgen_bitfield_unit . set (<span class="number">0usize </span>, <span class="number">8u8 </span>, { <span class="kw">let </span>tt : u32 = <span class="kw">unsafe </span>{ :: std :: mem :: transmute (tt) } ; tt <span class="kw">as </span>u64 }) ; __bindgen_bitfield_unit . set (<span class="number">8usize </span>, <span class="number">3u8 </span>, { <span class="kw">let </span>color : u32 = <span class="kw">unsafe </span>{ :: std :: mem :: transmute (color) } ; color <span class="kw">as </span>u64 }) ; __bindgen_bitfield_unit . set (<span class="number">11usize </span>, <span class="number">21u8 </span>, { <span class="kw">let </span>flags : u32 = <span class="kw">unsafe </span>{ :: std :: mem :: transmute (flags) } ; flags <span class="kw">as </span>u64 }) ; __bindgen_bitfield_unit } } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_range_ptr (mrb : * <span class="kw-2">mut </span>mrb_state , range : mrb_value) -&gt; * <span class="kw-2">mut </span>RRange ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_range_new (mrb : * <span class="kw-2">mut </span>mrb_state , start : mrb_value , end : mrb_value , exclude : mrb_bool) -&gt; mrb_value ; } # [repr (u32)] # [derive (Debug , Copy , Clone , Hash , PartialEq , Eq)] <span class="kw">pub enum </span>mrb_range_beg_len { MRB_RANGE_TYPE_MISMATCH = <span class="number">0 </span>, MRB_RANGE_OK = <span class="number">1 </span>, MRB_RANGE_OUT = <span class="number">2 </span>, } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_range_beg_len (mrb : * <span class="kw-2">mut </span>mrb_state , range : mrb_value , begp : * <span class="kw-2">mut </span>mrb_int , lenp : * <span class="kw-2">mut </span>mrb_int , len : mrb_int , trunc : mrb_bool) -&gt; mrb_range_beg_len ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub static </span>mrb_digitmap : [:: std :: os :: raw :: c_char ; <span class="number">0usize</span>] ; } # [repr (C)] # [derive (Copy , Clone)] <span class="kw">pub struct </span>RString { <span class="kw">pub </span>c : * <span class="kw-2">mut </span>RClass , <span class="kw">pub </span>gcnext : * <span class="kw-2">mut </span>RBasic , <span class="kw">pub </span>_bitfield_align_1 : [u32 ; <span class="number">0</span>] , <span class="kw">pub </span>_bitfield_1 : __BindgenBitfieldUnit &lt; [u8 ; <span class="number">4usize</span>] &gt; , <span class="kw">pub </span>as_ : RString__bindgen_ty_1 , } # [repr (C)] # [derive (Copy , Clone)] <span class="kw">pub union </span>RString__bindgen_ty_1 { <span class="kw">pub </span>heap : RString__bindgen_ty_1__bindgen_ty_1 , } # [repr (C)] # [derive (Copy , Clone)] <span class="kw">pub struct </span>RString__bindgen_ty_1__bindgen_ty_1 { <span class="kw">pub </span>len : mrb_ssize , <span class="kw">pub </span>aux : RString__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 , <span class="kw">pub </span>ptr : * <span class="kw-2">mut </span>:: std :: os :: raw :: c_char , } # [repr (C)] # [derive (Copy , Clone)] <span class="kw">pub union </span>RString__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 { <span class="kw">pub </span>capa : mrb_ssize , <span class="kw">pub </span>shared : * <span class="kw-2">mut </span>mrb_shared_string , <span class="kw">pub </span>fshared : * <span class="kw-2">mut </span>RString , } # [test] <span class="kw">fn </span>bindgen_test_layout_RString__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 () { <span class="kw">const </span>UNINIT : :: std :: mem :: MaybeUninit &lt; RString__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 &gt; = :: std :: mem :: MaybeUninit :: uninit () ; <span class="kw">let </span>ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: &lt; RString__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 &gt; () , <span class="number">8usize </span>, concat ! (<span class="string">"Size of: " </span>, stringify ! (RString__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1))) ; assert_eq ! (:: std :: mem :: align_of :: &lt; RString__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 &gt; () , <span class="number">8usize </span>, concat ! (<span class="string">"Alignment of " </span>, stringify ! (RString__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . capa) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">0usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (RString__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1) , <span class="string">"::" </span>, stringify ! (capa))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . shared) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">0usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (RString__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1) , <span class="string">"::" </span>, stringify ! (shared))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . fshared) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">0usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (RString__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1) , <span class="string">"::" </span>, stringify ! (fshared))) ; } # [test] <span class="kw">fn </span>bindgen_test_layout_RString__bindgen_ty_1__bindgen_ty_1 () { <span class="kw">const </span>UNINIT : :: std :: mem :: MaybeUninit &lt; RString__bindgen_ty_1__bindgen_ty_1 &gt; = :: std :: mem :: MaybeUninit :: uninit () ; <span class="kw">let </span>ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: &lt; RString__bindgen_ty_1__bindgen_ty_1 &gt; () , <span class="number">24usize </span>, concat ! (<span class="string">"Size of: " </span>, stringify ! (RString__bindgen_ty_1__bindgen_ty_1))) ; assert_eq ! (:: std :: mem :: align_of :: &lt; RString__bindgen_ty_1__bindgen_ty_1 &gt; () , <span class="number">8usize </span>, concat ! (<span class="string">"Alignment of " </span>, stringify ! (RString__bindgen_ty_1__bindgen_ty_1))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . len) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">0usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (RString__bindgen_ty_1__bindgen_ty_1) , <span class="string">"::" </span>, stringify ! (len))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . aux) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">8usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (RString__bindgen_ty_1__bindgen_ty_1) , <span class="string">"::" </span>, stringify ! (aux))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . ptr) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">16usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (RString__bindgen_ty_1__bindgen_ty_1) , <span class="string">"::" </span>, stringify ! (ptr))) ; } # [test] <span class="kw">fn </span>bindgen_test_layout_RString__bindgen_ty_1 () { <span class="kw">const </span>UNINIT : :: std :: mem :: MaybeUninit &lt; RString__bindgen_ty_1 &gt; = :: std :: mem :: MaybeUninit :: uninit () ; <span class="kw">let </span>ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: &lt; RString__bindgen_ty_1 &gt; () , <span class="number">24usize </span>, concat ! (<span class="string">"Size of: " </span>, stringify ! (RString__bindgen_ty_1))) ; assert_eq ! (:: std :: mem :: align_of :: &lt; RString__bindgen_ty_1 &gt; () , <span class="number">8usize </span>, concat ! (<span class="string">"Alignment of " </span>, stringify ! (RString__bindgen_ty_1))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . heap) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">0usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (RString__bindgen_ty_1) , <span class="string">"::" </span>, stringify ! (heap))) ; } # [test] <span class="kw">fn </span>bindgen_test_layout_RString () { <span class="kw">const </span>UNINIT : :: std :: mem :: MaybeUninit &lt; RString &gt; = :: std :: mem :: MaybeUninit :: uninit () ; <span class="kw">let </span>ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: &lt; RString &gt; () , <span class="number">48usize </span>, concat ! (<span class="string">"Size of: " </span>, stringify ! (RString))) ; assert_eq ! (:: std :: mem :: align_of :: &lt; RString &gt; () , <span class="number">8usize </span>, concat ! (<span class="string">"Alignment of " </span>, stringify ! (RString))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . c) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">0usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (RString) , <span class="string">"::" </span>, stringify ! (c))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . gcnext) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">8usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (RString) , <span class="string">"::" </span>, stringify ! (gcnext))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . as_) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">24usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (RString) , <span class="string">"::" </span>, stringify ! (as_))) ; } <span class="kw">impl </span>RString { # [inline] <span class="kw">pub fn </span>tt (&amp; <span class="self">self</span>) -&gt; mrb_vtype { <span class="kw">unsafe </span>{ :: std :: mem :: transmute (<span class="self">self </span>. _bitfield_1 . get (<span class="number">0usize </span>, <span class="number">8u8</span>) <span class="kw">as </span>u32) } } # [inline] <span class="kw">pub fn </span>set_tt (&amp; <span class="kw-2">mut </span><span class="self">self </span>, val : mrb_vtype) { <span class="kw">unsafe </span>{ <span class="kw">let </span>val : u32 = :: std :: mem :: transmute (val) ; <span class="self">self </span>. _bitfield_1 . set (<span class="number">0usize </span>, <span class="number">8u8 </span>, val <span class="kw">as </span>u64) } } # [inline] <span class="kw">pub fn </span>color (&amp; <span class="self">self</span>) -&gt; u32 { <span class="kw">unsafe </span>{ :: std :: mem :: transmute (<span class="self">self </span>. _bitfield_1 . get (<span class="number">8usize </span>, <span class="number">3u8</span>) <span class="kw">as </span>u32) } } # [inline] <span class="kw">pub fn </span>set_color (&amp; <span class="kw-2">mut </span><span class="self">self </span>, val : u32) { <span class="kw">unsafe </span>{ <span class="kw">let </span>val : u32 = :: std :: mem :: transmute (val) ; <span class="self">self </span>. _bitfield_1 . set (<span class="number">8usize </span>, <span class="number">3u8 </span>, val <span class="kw">as </span>u64) } } # [inline] <span class="kw">pub fn </span>flags (&amp; <span class="self">self</span>) -&gt; u32 { <span class="kw">unsafe </span>{ :: std :: mem :: transmute (<span class="self">self </span>. _bitfield_1 . get (<span class="number">11usize </span>, <span class="number">21u8</span>) <span class="kw">as </span>u32) } } # [inline] <span class="kw">pub fn </span>set_flags (&amp; <span class="kw-2">mut </span><span class="self">self </span>, val : u32) { <span class="kw">unsafe </span>{ <span class="kw">let </span>val : u32 = :: std :: mem :: transmute (val) ; <span class="self">self </span>. _bitfield_1 . set (<span class="number">11usize </span>, <span class="number">21u8 </span>, val <span class="kw">as </span>u64) } } # [inline] <span class="kw">pub fn </span>new_bitfield_1 (tt : mrb_vtype , color : u32 , flags : u32) -&gt; __BindgenBitfieldUnit &lt; [u8 ; <span class="number">4usize</span>] &gt; { <span class="kw">let </span><span class="kw-2">mut </span>__bindgen_bitfield_unit : __BindgenBitfieldUnit &lt; [u8 ; <span class="number">4usize</span>] &gt; = Default :: default () ; __bindgen_bitfield_unit . set (<span class="number">0usize </span>, <span class="number">8u8 </span>, { <span class="kw">let </span>tt : u32 = <span class="kw">unsafe </span>{ :: std :: mem :: transmute (tt) } ; tt <span class="kw">as </span>u64 }) ; __bindgen_bitfield_unit . set (<span class="number">8usize </span>, <span class="number">3u8 </span>, { <span class="kw">let </span>color : u32 = <span class="kw">unsafe </span>{ :: std :: mem :: transmute (color) } ; color <span class="kw">as </span>u64 }) ; __bindgen_bitfield_unit . set (<span class="number">11usize </span>, <span class="number">21u8 </span>, { <span class="kw">let </span>flags : u32 = <span class="kw">unsafe </span>{ :: std :: mem :: transmute (flags) } ; flags <span class="kw">as </span>u64 }) ; __bindgen_bitfield_unit } } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_str_modify (mrb : * <span class="kw-2">mut </span>mrb_state , s : * <span class="kw-2">mut </span>RString) ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_str_modify_keep_ascii (mrb : * <span class="kw-2">mut </span>mrb_state , s : * <span class="kw-2">mut </span>RString) ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_str_index (mrb : * <span class="kw-2">mut </span>mrb_state , str_ : mrb_value , p : * <span class="kw">const </span>:: std :: os :: raw :: c_char , len : mrb_int , offset : mrb_int) -&gt; mrb_int ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_str_concat (mrb : * <span class="kw-2">mut </span>mrb_state , self_ : mrb_value , other : mrb_value) ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_str_plus (mrb : * <span class="kw-2">mut </span>mrb_state , a : mrb_value , b : mrb_value) -&gt; mrb_value ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_ptr_to_str (mrb : * <span class="kw-2">mut </span>mrb_state , p : * <span class="kw-2">mut </span>:: std :: os :: raw :: c_void) -&gt; mrb_value ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_obj_as_string (mrb : * <span class="kw-2">mut </span>mrb_state , obj : mrb_value) -&gt; mrb_value ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_str_resize (mrb : * <span class="kw-2">mut </span>mrb_state , str_ : mrb_value , len : mrb_int) -&gt; mrb_value ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_str_substr (mrb : * <span class="kw-2">mut </span>mrb_state , str_ : mrb_value , beg : mrb_int , len : mrb_int) -&gt; mrb_value ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_str_new_capa (mrb : * <span class="kw-2">mut </span>mrb_state , capa : mrb_int) -&gt; mrb_value ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_string_cstr (mrb : * <span class="kw-2">mut </span>mrb_state , str_ : mrb_value) -&gt; * <span class="kw">const </span>:: std :: os :: raw :: c_char ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_string_value_cstr (mrb : * <span class="kw-2">mut </span>mrb_state , str_ : * <span class="kw-2">mut </span>mrb_value) -&gt; * <span class="kw">const </span>:: std :: os :: raw :: c_char ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_str_dup (mrb : * <span class="kw-2">mut </span>mrb_state , str_ : mrb_value) -&gt; mrb_value ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_str_intern (mrb : * <span class="kw-2">mut </span>mrb_state , self_ : mrb_value) -&gt; mrb_value ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_str_to_integer (mrb : * <span class="kw-2">mut </span>mrb_state , str_ : mrb_value , base : mrb_int , badcheck : mrb_bool) -&gt; mrb_value ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_str_to_dbl (mrb : * <span class="kw-2">mut </span>mrb_state , str_ : mrb_value , badcheck : mrb_bool) -&gt; f64 ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_str_equal (mrb : * <span class="kw-2">mut </span>mrb_state , str1 : mrb_value , str2 : mrb_value) -&gt; mrb_bool ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_str_cat (mrb : * <span class="kw-2">mut </span>mrb_state , str_ : mrb_value , ptr : * <span class="kw">const </span>:: std :: os :: raw :: c_char , len : usize) -&gt; mrb_value ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_str_cat_cstr (mrb : * <span class="kw-2">mut </span>mrb_state , str_ : mrb_value , ptr : * <span class="kw">const </span>:: std :: os :: raw :: c_char) -&gt; mrb_value ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_str_cat_str (mrb : * <span class="kw-2">mut </span>mrb_state , str_ : mrb_value , str2 : mrb_value) -&gt; mrb_value ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_str_append (mrb : * <span class="kw-2">mut </span>mrb_state , str_ : mrb_value , str2 : mrb_value) -&gt; mrb_value ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_str_cmp (mrb : * <span class="kw-2">mut </span>mrb_state , str1 : mrb_value , str2 : mrb_value) -&gt; :: std :: os :: raw :: c_int ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_str_to_cstr (mrb : * <span class="kw-2">mut </span>mrb_state , str_ : mrb_value) -&gt; * <span class="kw-2">mut </span>:: std :: os :: raw :: c_char ; } <span class="kw">pub type </span>__jmp_buf = [:: std :: os :: raw :: c_long ; <span class="number">8usize</span>] ; # [repr (C)] # [derive (Debug , Copy , Clone)] <span class="kw">pub struct </span>__jmp_buf_tag { <span class="kw">pub </span>__jmpbuf : __jmp_buf , <span class="kw">pub </span>__mask_was_saved : :: std :: os :: raw :: c_int , <span class="kw">pub </span>__saved_mask : __sigset_t , } # [test] <span class="kw">fn </span>bindgen_test_layout___jmp_buf_tag () { <span class="kw">const </span>UNINIT : :: std :: mem :: MaybeUninit &lt; __jmp_buf_tag &gt; = :: std :: mem :: MaybeUninit :: uninit () ; <span class="kw">let </span>ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: &lt; __jmp_buf_tag &gt; () , <span class="number">200usize </span>, concat ! (<span class="string">"Size of: " </span>, stringify ! (__jmp_buf_tag))) ; assert_eq ! (:: std :: mem :: align_of :: &lt; __jmp_buf_tag &gt; () , <span class="number">8usize </span>, concat ! (<span class="string">"Alignment of " </span>, stringify ! (__jmp_buf_tag))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . __jmpbuf) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">0usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (__jmp_buf_tag) , <span class="string">"::" </span>, stringify ! (__jmpbuf))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . __mask_was_saved) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">64usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (__jmp_buf_tag) , <span class="string">"::" </span>, stringify ! (__mask_was_saved))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . __saved_mask) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">72usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (__jmp_buf_tag) , <span class="string">"::" </span>, stringify ! (__saved_mask))) ; } <span class="kw">pub type </span>jmp_buf = [__jmp_buf_tag ; <span class="number">1usize</span>] ; # [repr (C)] # [derive (Debug , Copy , Clone)] <span class="kw">pub struct </span>mrb_jmpbuf { <span class="kw">pub </span>impl_ : jmp_buf , } # [test] <span class="kw">fn </span>bindgen_test_layout_mrb_jmpbuf () { <span class="kw">const </span>UNINIT : :: std :: mem :: MaybeUninit &lt; mrb_jmpbuf &gt; = :: std :: mem :: MaybeUninit :: uninit () ; <span class="kw">let </span>ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: &lt; mrb_jmpbuf &gt; () , <span class="number">200usize </span>, concat ! (<span class="string">"Size of: " </span>, stringify ! (mrb_jmpbuf))) ; assert_eq ! (:: std :: mem :: align_of :: &lt; mrb_jmpbuf &gt; () , <span class="number">8usize </span>, concat ! (<span class="string">"Alignment of " </span>, stringify ! (mrb_jmpbuf))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . impl_) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">0usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (mrb_jmpbuf) , <span class="string">"::" </span>, stringify ! (impl_))) ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_const_get (arg1 : * <span class="kw-2">mut </span>mrb_state , arg2 : mrb_value , arg3 : mrb_sym) -&gt; mrb_value ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_const_set (arg1 : * <span class="kw-2">mut </span>mrb_state , arg2 : mrb_value , arg3 : mrb_sym , arg4 : mrb_value) ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_const_defined (arg1 : * <span class="kw-2">mut </span>mrb_state , arg2 : mrb_value , arg3 : mrb_sym) -&gt; mrb_bool ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_const_remove (arg1 : * <span class="kw-2">mut </span>mrb_state , arg2 : mrb_value , arg3 : mrb_sym) ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_iv_name_sym_p (mrb : * <span class="kw-2">mut </span>mrb_state , sym : mrb_sym) -&gt; mrb_bool ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_iv_name_sym_check (mrb : * <span class="kw-2">mut </span>mrb_state , sym : mrb_sym) ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_obj_iv_get (mrb : * <span class="kw-2">mut </span>mrb_state , obj : * <span class="kw-2">mut </span>RObject , sym : mrb_sym) -&gt; mrb_value ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_obj_iv_set (mrb : * <span class="kw-2">mut </span>mrb_state , obj : * <span class="kw-2">mut </span>RObject , sym : mrb_sym , v : mrb_value) ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_obj_iv_defined (mrb : * <span class="kw-2">mut </span>mrb_state , obj : * <span class="kw-2">mut </span>RObject , sym : mrb_sym) -&gt; mrb_bool ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_iv_get (mrb : * <span class="kw-2">mut </span>mrb_state , obj : mrb_value , sym : mrb_sym) -&gt; mrb_value ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_iv_set (mrb : * <span class="kw-2">mut </span>mrb_state , obj : mrb_value , sym : mrb_sym , v : mrb_value) ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_iv_defined (arg1 : * <span class="kw-2">mut </span>mrb_state , arg2 : mrb_value , arg3 : mrb_sym) -&gt; mrb_bool ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_iv_remove (mrb : * <span class="kw-2">mut </span>mrb_state , obj : mrb_value , sym : mrb_sym) -&gt; mrb_value ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_iv_copy (mrb : * <span class="kw-2">mut </span>mrb_state , dst : mrb_value , src : mrb_value) ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_const_defined_at (mrb : * <span class="kw-2">mut </span>mrb_state , mod_ : mrb_value , id : mrb_sym) -&gt; mrb_bool ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_gv_get (mrb : * <span class="kw-2">mut </span>mrb_state , sym : mrb_sym) -&gt; mrb_value ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_gv_set (mrb : * <span class="kw-2">mut </span>mrb_state , sym : mrb_sym , val : mrb_value) ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_gv_remove (mrb : * <span class="kw-2">mut </span>mrb_state , sym : mrb_sym) ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_cv_get (mrb : * <span class="kw-2">mut </span>mrb_state , mod_ : mrb_value , sym : mrb_sym) -&gt; mrb_value ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_mod_cv_set (mrb : * <span class="kw-2">mut </span>mrb_state , c : * <span class="kw-2">mut </span>RClass , sym : mrb_sym , v : mrb_value) ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_cv_set (mrb : * <span class="kw-2">mut </span>mrb_state , mod_ : mrb_value , sym : mrb_sym , v : mrb_value) ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_cv_defined (mrb : * <span class="kw-2">mut </span>mrb_state , mod_ : mrb_value , sym : mrb_sym) -&gt; mrb_bool ; } <span class="kw">pub type </span>mrb_iv_foreach_func = :: std :: option :: <span class="prelude-ty">Option </span>&lt; <span class="kw">unsafe extern </span><span class="string">"C" </span><span class="kw">fn </span>(arg1 : * <span class="kw-2">mut </span>mrb_state , arg2 : mrb_sym , arg3 : mrb_value , arg4 : * <span class="kw-2">mut </span>:: std :: os :: raw :: c_void) -&gt; :: std :: os :: raw :: c_int &gt; ; <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_iv_foreach (mrb : * <span class="kw-2">mut </span>mrb_state , obj : mrb_value , func : mrb_iv_foreach_func , p : * <span class="kw-2">mut </span>:: std :: os :: raw :: c_void) ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_sys_value_has_method (mrb : * <span class="kw-2">mut </span>mrb_state , value : mrb_value , method : mrb_sym) -&gt; bool ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_sys_value_is_nil (value : mrb_value) -&gt; bool ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_sys_value_is_false (value : mrb_value) -&gt; bool ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_sys_value_is_true (value : mrb_value) -&gt; bool ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_sys_range_excl (mrb : * <span class="kw-2">mut </span>mrb_state , value : mrb_value) -&gt; bool ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_sys_obj_frozen (mrb : * <span class="kw-2">mut </span>mrb_state , value : mrb_value) -&gt; bool ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_sys_fixnum_to_cint (value : mrb_value) -&gt; mrb_int ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_sys_float_to_cdouble (value : mrb_value) -&gt; mrb_float ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_sys_cptr_ptr (value : mrb_value) -&gt; * <span class="kw-2">mut </span>:: std :: os :: raw :: c_void ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_sys_basic_ptr (value : mrb_value) -&gt; * <span class="kw-2">mut </span>RBasic ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_sys_obj_ptr (value : mrb_value) -&gt; * <span class="kw-2">mut </span>RObject ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_sys_proc_ptr (value : mrb_value) -&gt; * <span class="kw-2">mut </span>RProc ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_sys_class_ptr (value : mrb_value) -&gt; * <span class="kw-2">mut </span>RClass ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_sys_class_to_rclass (value : mrb_value) -&gt; * <span class="kw-2">mut </span>RClass ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_sys_class_of_value (mrb : * <span class="kw-2">mut </span>mrb_state , value : mrb_value) -&gt; * <span class="kw-2">mut </span>RClass ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_sys_nil_value () -&gt; mrb_value ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_sys_false_value () -&gt; mrb_value ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_sys_true_value () -&gt; mrb_value ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_sys_fixnum_value (value : mrb_int) -&gt; mrb_value ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_sys_float_value (mrb : * <span class="kw-2">mut </span>mrb_state , value : mrb_float) -&gt; mrb_value ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_sys_cptr_value (mrb : * <span class="kw-2">mut </span>mrb_state , ptr : * <span class="kw-2">mut </span>:: std :: os :: raw :: c_void) -&gt; mrb_value ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_sys_obj_value (p : * <span class="kw-2">mut </span>:: std :: os :: raw :: c_void) -&gt; mrb_value ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_sys_class_value (klass : * <span class="kw-2">mut </span>RClass) -&gt; mrb_value ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_sys_module_value (module : * <span class="kw-2">mut </span>RClass) -&gt; mrb_value ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_sys_data_value (data : * <span class="kw-2">mut </span>RData) -&gt; mrb_value ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_sys_proc_value (mrb : * <span class="kw-2">mut </span>mrb_state , proc_ : * <span class="kw-2">mut </span>RProc) -&gt; mrb_value ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_sys_new_symbol (id : mrb_sym) -&gt; mrb_value ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_sys_set_instance_tt (klass : * <span class="kw-2">mut </span>RClass , type_ : mrb_vtype) ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_sys_data_init (value : * <span class="kw-2">mut </span>mrb_value , ptr : * <span class="kw-2">mut </span>:: std :: os :: raw :: c_void , type_ : * <span class="kw">const </span>mrb_data_type) ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_sys_raise (mrb : * <span class="kw-2">mut </span>mrb_state , eklass : * <span class="kw">const </span>:: std :: os :: raw :: c_char , msg : * <span class="kw">const </span>:: std :: os :: raw :: c_char) ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_sys_raise_current_exception (mrb : * <span class="kw-2">mut </span>mrb_state) ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_sys_alloc_rarray (mrb : * <span class="kw-2">mut </span>mrb_state , ptr : * <span class="kw-2">mut </span>mrb_value , len : mrb_int , capa : mrb_int) -&gt; mrb_value ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_sys_repack_into_rarray (ptr : * <span class="kw-2">mut </span>mrb_value , len : mrb_int , capa : mrb_int , into : mrb_value) ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_sys_alloc_rstring (mrb : * <span class="kw-2">mut </span>mrb_state , ptr : * <span class="kw-2">mut </span>:: std :: os :: raw :: c_char , len : mrb_int , capa : mrb_int) -&gt; mrb_value ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_sys_repack_into_rstring (ptr : * <span class="kw-2">mut </span>:: std :: os :: raw :: c_char , len : mrb_int , capa : mrb_int , into : mrb_value) -&gt; * <span class="kw-2">mut </span>RString ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_sys_gc_arena_save (mrb : * <span class="kw-2">mut </span>mrb_state) -&gt; :: std :: os :: raw :: c_int ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_sys_gc_arena_restore (mrb : * <span class="kw-2">mut </span>mrb_state , arena_index : :: std :: os :: raw :: c_int) ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_sys_gc_disable (mrb : * <span class="kw-2">mut </span>mrb_state) -&gt; bool ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_sys_gc_enable (mrb : * <span class="kw-2">mut </span>mrb_state) -&gt; bool ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_sys_value_is_dead (_mrb : * <span class="kw-2">mut </span>mrb_state , value : mrb_value) -&gt; bool ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_sys_gc_live_objects (mrb : * <span class="kw-2">mut </span>mrb_state) -&gt; usize ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_sys_safe_gc_mark (mrb : * <span class="kw-2">mut </span>mrb_state , value : mrb_value) ; } <span class="kw">extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_init_mrbgems (mrb : * <span class="kw-2">mut </span>mrb_state) ; } <span class="kw">pub type </span>__builtin_va_list = [__va_list_tag ; <span class="number">1usize</span>] ; # [repr (C)] # [derive (Debug , Copy , Clone)] <span class="kw">pub struct </span>__va_list_tag { <span class="kw">pub </span>gp_offset : :: std :: os :: raw :: c_uint , <span class="kw">pub </span>fp_offset : :: std :: os :: raw :: c_uint , <span class="kw">pub </span>overflow_arg_area : * <span class="kw-2">mut </span>:: std :: os :: raw :: c_void , <span class="kw">pub </span>reg_save_area : * <span class="kw-2">mut </span>:: std :: os :: raw :: c_void , } # [test] <span class="kw">fn </span>bindgen_test_layout___va_list_tag () { <span class="kw">const </span>UNINIT : :: std :: mem :: MaybeUninit &lt; __va_list_tag &gt; = :: std :: mem :: MaybeUninit :: uninit () ; <span class="kw">let </span>ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: &lt; __va_list_tag &gt; () , <span class="number">24usize </span>, concat ! (<span class="string">"Size of: " </span>, stringify ! (__va_list_tag))) ; assert_eq ! (:: std :: mem :: align_of :: &lt; __va_list_tag &gt; () , <span class="number">8usize </span>, concat ! (<span class="string">"Alignment of " </span>, stringify ! (__va_list_tag))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . gp_offset) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">0usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (__va_list_tag) , <span class="string">"::" </span>, stringify ! (gp_offset))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . fp_offset) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">4usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (__va_list_tag) , <span class="string">"::" </span>, stringify ! (fp_offset))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . overflow_arg_area) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">8usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (__va_list_tag) , <span class="string">"::" </span>, stringify ! (overflow_arg_area))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . reg_save_area) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">16usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (__va_list_tag) , <span class="string">"::" </span>, stringify ! (reg_save_area))) ; } # [repr (C)] # [derive (Debug , Copy , Clone)] <span class="kw">pub struct </span>iv_tbl { <span class="kw">pub </span>_address : u8 , } # [repr (C)] # [derive (Debug , Copy , Clone)] <span class="kw">pub struct </span>mt_tbl { <span class="kw">pub </span>_address : u8 , } # [repr (C)] # [derive (Debug , Copy , Clone)] <span class="kw">pub struct </span>parser_lex_strterm { <span class="kw">pub </span>_address : u8 , } # [repr (C)] # [derive (Debug , Copy , Clone)] <span class="kw">pub struct </span>mrb_irep_debug_info { <span class="kw">pub </span>_address : u8 , } # [repr (C)] # [derive (Debug , Copy , Clone)] <span class="kw">pub struct </span>hash_entry { <span class="kw">pub </span>_address : u8 , } # [repr (C)] # [derive (Debug , Copy , Clone)] <span class="kw">pub struct </span>hash_table { <span class="kw">pub </span>_address : u8 , } # [repr (C)] # [derive (Debug , Copy , Clone)] <span class="kw">pub struct </span>mrb_shared_string { <span class="kw">pub </span>_address : u8 , }</code></pre></div></section></main></body></html>